[
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "stringify",
        "importPath": "flatted",
        "description": "flatted",
        "isExtraImport": true,
        "detail": "flatted",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "flatted",
        "description": "flatted",
        "isExtraImport": true,
        "detail": "flatted",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "sleep",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "sleep",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "sleep",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "strftime",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "RPi.GPIO",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "RPi.GPIO",
        "description": "RPi.GPIO",
        "detail": "RPi.GPIO",
        "documentation": {}
    },
    {
        "label": "paho.mqtt.client",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "paho.mqtt.client",
        "description": "paho.mqtt.client",
        "detail": "paho.mqtt.client",
        "documentation": {}
    },
    {
        "label": "Queue",
        "importPath": "queue",
        "description": "queue",
        "isExtraImport": true,
        "detail": "queue",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Event",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Thread",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "publish",
        "importPath": "paho.mqtt",
        "description": "paho.mqtt",
        "isExtraImport": true,
        "detail": "paho.mqtt",
        "documentation": {}
    },
    {
        "label": "publish",
        "importPath": "paho.mqtt",
        "description": "paho.mqtt",
        "isExtraImport": true,
        "detail": "paho.mqtt",
        "documentation": {}
    },
    {
        "label": "publish",
        "importPath": "paho.mqtt",
        "description": "paho.mqtt",
        "isExtraImport": true,
        "detail": "paho.mqtt",
        "documentation": {}
    },
    {
        "label": "publish",
        "importPath": "paho.mqtt",
        "description": "paho.mqtt",
        "isExtraImport": true,
        "detail": "paho.mqtt",
        "documentation": {}
    },
    {
        "label": "publish",
        "importPath": "paho.mqtt",
        "description": "paho.mqtt",
        "isExtraImport": true,
        "detail": "paho.mqtt",
        "documentation": {}
    },
    {
        "label": "publish",
        "importPath": "paho.mqtt",
        "description": "paho.mqtt",
        "isExtraImport": true,
        "detail": "paho.mqtt",
        "documentation": {}
    },
    {
        "label": "publish",
        "importPath": "paho.mqtt",
        "description": "paho.mqtt",
        "isExtraImport": true,
        "detail": "paho.mqtt",
        "documentation": {}
    },
    {
        "label": "publish",
        "importPath": "paho.mqtt",
        "description": "paho.mqtt",
        "isExtraImport": true,
        "detail": "paho.mqtt",
        "documentation": {}
    },
    {
        "label": "publish",
        "importPath": "paho.mqtt",
        "description": "paho.mqtt",
        "isExtraImport": true,
        "detail": "paho.mqtt",
        "documentation": {}
    },
    {
        "label": "publish",
        "importPath": "paho.mqtt",
        "description": "paho.mqtt",
        "isExtraImport": true,
        "detail": "paho.mqtt",
        "documentation": {}
    },
    {
        "label": "publish",
        "importPath": "paho.mqtt",
        "description": "paho.mqtt",
        "isExtraImport": true,
        "detail": "paho.mqtt",
        "documentation": {}
    },
    {
        "label": "lock",
        "importPath": "settings.settings",
        "description": "settings.settings",
        "isExtraImport": true,
        "detail": "settings.settings",
        "documentation": {}
    },
    {
        "label": "HOSTNAME",
        "importPath": "settings.settings",
        "description": "settings.settings",
        "isExtraImport": true,
        "detail": "settings.settings",
        "documentation": {}
    },
    {
        "label": "PORT",
        "importPath": "settings.settings",
        "description": "settings.settings",
        "isExtraImport": true,
        "detail": "settings.settings",
        "documentation": {}
    },
    {
        "label": "lock",
        "importPath": "settings.settings",
        "description": "settings.settings",
        "isExtraImport": true,
        "detail": "settings.settings",
        "documentation": {}
    },
    {
        "label": "HOSTNAME",
        "importPath": "settings.settings",
        "description": "settings.settings",
        "isExtraImport": true,
        "detail": "settings.settings",
        "documentation": {}
    },
    {
        "label": "PORT",
        "importPath": "settings.settings",
        "description": "settings.settings",
        "isExtraImport": true,
        "detail": "settings.settings",
        "documentation": {}
    },
    {
        "label": "lock",
        "importPath": "settings.settings",
        "description": "settings.settings",
        "isExtraImport": true,
        "detail": "settings.settings",
        "documentation": {}
    },
    {
        "label": "HOSTNAME",
        "importPath": "settings.settings",
        "description": "settings.settings",
        "isExtraImport": true,
        "detail": "settings.settings",
        "documentation": {}
    },
    {
        "label": "PORT",
        "importPath": "settings.settings",
        "description": "settings.settings",
        "isExtraImport": true,
        "detail": "settings.settings",
        "documentation": {}
    },
    {
        "label": "lock",
        "importPath": "settings.settings",
        "description": "settings.settings",
        "isExtraImport": true,
        "detail": "settings.settings",
        "documentation": {}
    },
    {
        "label": "HOSTNAME",
        "importPath": "settings.settings",
        "description": "settings.settings",
        "isExtraImport": true,
        "detail": "settings.settings",
        "documentation": {}
    },
    {
        "label": "PORT",
        "importPath": "settings.settings",
        "description": "settings.settings",
        "isExtraImport": true,
        "detail": "settings.settings",
        "documentation": {}
    },
    {
        "label": "lock",
        "importPath": "settings.settings",
        "description": "settings.settings",
        "isExtraImport": true,
        "detail": "settings.settings",
        "documentation": {}
    },
    {
        "label": "HOSTNAME",
        "importPath": "settings.settings",
        "description": "settings.settings",
        "isExtraImport": true,
        "detail": "settings.settings",
        "documentation": {}
    },
    {
        "label": "PORT",
        "importPath": "settings.settings",
        "description": "settings.settings",
        "isExtraImport": true,
        "detail": "settings.settings",
        "documentation": {}
    },
    {
        "label": "lock",
        "importPath": "settings.settings",
        "description": "settings.settings",
        "isExtraImport": true,
        "detail": "settings.settings",
        "documentation": {}
    },
    {
        "label": "HOSTNAME",
        "importPath": "settings.settings",
        "description": "settings.settings",
        "isExtraImport": true,
        "detail": "settings.settings",
        "documentation": {}
    },
    {
        "label": "PORT",
        "importPath": "settings.settings",
        "description": "settings.settings",
        "isExtraImport": true,
        "detail": "settings.settings",
        "documentation": {}
    },
    {
        "label": "lock",
        "importPath": "settings.settings",
        "description": "settings.settings",
        "isExtraImport": true,
        "detail": "settings.settings",
        "documentation": {}
    },
    {
        "label": "HOSTNAME",
        "importPath": "settings.settings",
        "description": "settings.settings",
        "isExtraImport": true,
        "detail": "settings.settings",
        "documentation": {}
    },
    {
        "label": "PORT",
        "importPath": "settings.settings",
        "description": "settings.settings",
        "isExtraImport": true,
        "detail": "settings.settings",
        "documentation": {}
    },
    {
        "label": "lock",
        "importPath": "settings.settings",
        "description": "settings.settings",
        "isExtraImport": true,
        "detail": "settings.settings",
        "documentation": {}
    },
    {
        "label": "HOSTNAME",
        "importPath": "settings.settings",
        "description": "settings.settings",
        "isExtraImport": true,
        "detail": "settings.settings",
        "documentation": {}
    },
    {
        "label": "PORT",
        "importPath": "settings.settings",
        "description": "settings.settings",
        "isExtraImport": true,
        "detail": "settings.settings",
        "documentation": {}
    },
    {
        "label": "lock",
        "importPath": "settings.settings",
        "description": "settings.settings",
        "isExtraImport": true,
        "detail": "settings.settings",
        "documentation": {}
    },
    {
        "label": "HOSTNAME",
        "importPath": "settings.settings",
        "description": "settings.settings",
        "isExtraImport": true,
        "detail": "settings.settings",
        "documentation": {}
    },
    {
        "label": "PORT",
        "importPath": "settings.settings",
        "description": "settings.settings",
        "isExtraImport": true,
        "detail": "settings.settings",
        "documentation": {}
    },
    {
        "label": "lock",
        "importPath": "settings.settings",
        "description": "settings.settings",
        "isExtraImport": true,
        "detail": "settings.settings",
        "documentation": {}
    },
    {
        "label": "HOSTNAME",
        "importPath": "settings.settings",
        "description": "settings.settings",
        "isExtraImport": true,
        "detail": "settings.settings",
        "documentation": {}
    },
    {
        "label": "PORT",
        "importPath": "settings.settings",
        "description": "settings.settings",
        "isExtraImport": true,
        "detail": "settings.settings",
        "documentation": {}
    },
    {
        "label": "lock",
        "importPath": "settings.settings",
        "description": "settings.settings",
        "isExtraImport": true,
        "detail": "settings.settings",
        "documentation": {}
    },
    {
        "label": "HOSTNAME",
        "importPath": "settings.settings",
        "description": "settings.settings",
        "isExtraImport": true,
        "detail": "settings.settings",
        "documentation": {}
    },
    {
        "label": "PORT",
        "importPath": "settings.settings",
        "description": "settings.settings",
        "isExtraImport": true,
        "detail": "settings.settings",
        "documentation": {}
    },
    {
        "label": "load_settings",
        "importPath": "settings.settings",
        "description": "settings.settings",
        "isExtraImport": true,
        "detail": "settings.settings",
        "documentation": {}
    },
    {
        "label": "HOSTNAME",
        "importPath": "settings.settings",
        "description": "settings.settings",
        "isExtraImport": true,
        "detail": "settings.settings",
        "documentation": {}
    },
    {
        "label": "PORT",
        "importPath": "settings.settings",
        "description": "settings.settings",
        "isExtraImport": true,
        "detail": "settings.settings",
        "documentation": {}
    },
    {
        "label": "run_ir_simulator",
        "importPath": "simulations.IR",
        "description": "simulations.IR",
        "isExtraImport": true,
        "detail": "simulations.IR",
        "documentation": {}
    },
    {
        "label": "run_b4sd_simulator",
        "importPath": "simulations.b4sd",
        "description": "simulations.b4sd",
        "isExtraImport": true,
        "detail": "simulations.b4sd",
        "documentation": {}
    },
    {
        "label": "run_ms_simulator",
        "importPath": "simulations.ms",
        "description": "simulations.ms",
        "isExtraImport": true,
        "detail": "simulations.ms",
        "documentation": {}
    },
    {
        "label": "run_ms_simulator",
        "importPath": "simulations.ms",
        "description": "simulations.ms",
        "isExtraImport": true,
        "detail": "simulations.ms",
        "documentation": {}
    },
    {
        "label": "run_button_simulator",
        "importPath": "simulations.button",
        "description": "simulations.button",
        "isExtraImport": true,
        "detail": "simulations.button",
        "documentation": {}
    },
    {
        "label": "run_buzzer_simulator",
        "importPath": "simulations.buzzer",
        "description": "simulations.buzzer",
        "isExtraImport": true,
        "detail": "simulations.buzzer",
        "documentation": {}
    },
    {
        "label": "run_dht_simulator",
        "importPath": "simulations.dht",
        "description": "simulations.dht",
        "isExtraImport": true,
        "detail": "simulations.dht",
        "documentation": {}
    },
    {
        "label": "run_dht_simulator",
        "importPath": "simulations.dht",
        "description": "simulations.dht",
        "isExtraImport": true,
        "detail": "simulations.dht",
        "documentation": {}
    },
    {
        "label": "run_dht_simulator",
        "importPath": "simulations.dht",
        "description": "simulations.dht",
        "isExtraImport": true,
        "detail": "simulations.dht",
        "documentation": {}
    },
    {
        "label": "run_dioda_simulator",
        "importPath": "simulations.dioda",
        "description": "simulations.dioda",
        "isExtraImport": true,
        "detail": "simulations.dioda",
        "documentation": {}
    },
    {
        "label": "run_gyro_simulator",
        "importPath": "simulations.gyro",
        "description": "simulations.gyro",
        "isExtraImport": true,
        "detail": "simulations.gyro",
        "documentation": {}
    },
    {
        "label": "run_lcd_simulator",
        "importPath": "simulations.lcd",
        "description": "simulations.lcd",
        "isExtraImport": true,
        "detail": "simulations.lcd",
        "documentation": {}
    },
    {
        "label": "run_pir_simulator",
        "importPath": "simulations.pir",
        "description": "simulations.pir",
        "isExtraImport": true,
        "detail": "simulations.pir",
        "documentation": {}
    },
    {
        "label": "run_rgb_simulator",
        "importPath": "simulations.rgb",
        "description": "simulations.rgb",
        "isExtraImport": true,
        "detail": "simulations.rgb",
        "documentation": {}
    },
    {
        "label": "run_uds_simulator",
        "importPath": "simulations.uds",
        "description": "simulations.uds",
        "isExtraImport": true,
        "detail": "simulations.uds",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "sqrt",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "ctypes",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ctypes",
        "description": "ctypes",
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "smbus",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "smbus",
        "description": "smbus",
        "detail": "smbus",
        "documentation": {}
    },
    {
        "label": "csv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "csv",
        "description": "csv",
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "MPUConstants",
        "importPath": "MPUConstants",
        "description": "MPUConstants",
        "isExtraImport": true,
        "detail": "MPUConstants",
        "documentation": {}
    },
    {
        "label": "Quaternion",
        "importPath": "Quaternion",
        "description": "Quaternion",
        "isExtraImport": true,
        "detail": "Quaternion",
        "documentation": {}
    },
    {
        "label": "XYZVector",
        "importPath": "Quaternion",
        "description": "Quaternion",
        "isExtraImport": true,
        "detail": "Quaternion",
        "documentation": {}
    },
    {
        "label": "MPU6050",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "MPU6050",
        "description": "MPU6050",
        "detail": "MPU6050",
        "documentation": {}
    },
    {
        "label": "MPU6050",
        "importPath": "MPU6050",
        "description": "MPU6050",
        "isExtraImport": true,
        "detail": "MPU6050",
        "documentation": {}
    },
    {
        "label": "SimplePID",
        "importPath": "SimplePID",
        "description": "SimplePID",
        "isExtraImport": true,
        "detail": "SimplePID",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "PCF8574_GPIO",
        "importPath": "PCF8574",
        "description": "PCF8574",
        "isExtraImport": true,
        "detail": "PCF8574",
        "documentation": {}
    },
    {
        "label": "Adafruit_CharLCD",
        "importPath": "Adafruit_LCD1602",
        "description": "Adafruit_LCD1602",
        "isExtraImport": true,
        "detail": "Adafruit_LCD1602",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "multiprocessing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "run_button",
        "importPath": "components.button",
        "description": "components.button",
        "isExtraImport": true,
        "detail": "components.button",
        "documentation": {}
    },
    {
        "label": "run_ms",
        "importPath": "components.ms",
        "description": "components.ms",
        "isExtraImport": true,
        "detail": "components.ms",
        "documentation": {}
    },
    {
        "label": "run_dioda",
        "importPath": "components.dioda",
        "description": "components.dioda",
        "isExtraImport": true,
        "detail": "components.dioda",
        "documentation": {}
    },
    {
        "label": "run_uds",
        "importPath": "components.uds",
        "description": "components.uds",
        "isExtraImport": true,
        "detail": "components.uds",
        "documentation": {}
    },
    {
        "label": "run_dht",
        "importPath": "components.dht",
        "description": "components.dht",
        "isExtraImport": true,
        "detail": "components.dht",
        "documentation": {}
    },
    {
        "label": "run_pir",
        "importPath": "components.pir",
        "description": "components.pir",
        "isExtraImport": true,
        "detail": "components.pir",
        "documentation": {}
    },
    {
        "label": "run_buzzer",
        "importPath": "components.buzzer",
        "description": "components.buzzer",
        "isExtraImport": true,
        "detail": "components.buzzer",
        "documentation": {}
    },
    {
        "label": "run_gyro",
        "importPath": "components.gyro",
        "description": "components.gyro",
        "isExtraImport": true,
        "detail": "components.gyro",
        "documentation": {}
    },
    {
        "label": "run_lcd",
        "importPath": "components.lcd",
        "description": "components.lcd",
        "isExtraImport": true,
        "detail": "components.lcd",
        "documentation": {}
    },
    {
        "label": "run_b4sd",
        "importPath": "components.b4sd",
        "description": "components.b4sd",
        "isExtraImport": true,
        "detail": "components.b4sd",
        "documentation": {}
    },
    {
        "label": "run_infrared",
        "importPath": "components.IR",
        "description": "components.IR",
        "isExtraImport": true,
        "detail": "components.IR",
        "documentation": {}
    },
    {
        "label": "run_rgb",
        "importPath": "components.rgb",
        "description": "components.rgb",
        "isExtraImport": true,
        "detail": "components.rgb",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "SocketIO",
        "importPath": "flask_socketio",
        "description": "flask_socketio",
        "isExtraImport": true,
        "detail": "flask_socketio",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "CORS",
        "importPath": "flask_cors",
        "description": "flask_cors",
        "isExtraImport": true,
        "detail": "flask_cors",
        "documentation": {}
    },
    {
        "label": "cross_origin",
        "importPath": "flask_cors",
        "description": "flask_cors",
        "isExtraImport": true,
        "detail": "flask_cors",
        "documentation": {}
    },
    {
        "label": "InfluxDBClient",
        "importPath": "influxdb_client",
        "description": "influxdb_client",
        "isExtraImport": true,
        "detail": "influxdb_client",
        "documentation": {}
    },
    {
        "label": "Point",
        "importPath": "influxdb_client",
        "description": "influxdb_client",
        "isExtraImport": true,
        "detail": "influxdb_client",
        "documentation": {}
    },
    {
        "label": "SYNCHRONOUS",
        "importPath": "influxdb_client.client.write_api",
        "description": "influxdb_client.client.write_api",
        "isExtraImport": true,
        "detail": "influxdb_client.client.write_api",
        "documentation": {}
    },
    {
        "label": "load_settings",
        "importPath": "settings",
        "description": "settings",
        "isExtraImport": true,
        "detail": "settings",
        "documentation": {}
    },
    {
        "label": "_Known",
        "kind": 6,
        "importPath": "front.node_modules.flatted.python.flatted",
        "description": "front.node_modules.flatted.python.flatted",
        "peekOfCode": "class _Known:\n    def __init__(self):\n        self.key = []\n        self.value = []\nclass _String:\n    def __init__(self, value):\n        self.value = value\ndef _array_keys(value):\n    keys = []\n    i = 0",
        "detail": "front.node_modules.flatted.python.flatted",
        "documentation": {}
    },
    {
        "label": "_String",
        "kind": 6,
        "importPath": "front.node_modules.flatted.python.flatted",
        "description": "front.node_modules.flatted.python.flatted",
        "peekOfCode": "class _String:\n    def __init__(self, value):\n        self.value = value\ndef _array_keys(value):\n    keys = []\n    i = 0\n    for _ in value:\n        keys.append(i)\n        i += 1\n    return keys",
        "detail": "front.node_modules.flatted.python.flatted",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 2,
        "importPath": "front.node_modules.flatted.python.flatted",
        "description": "front.node_modules.flatted.python.flatted",
        "peekOfCode": "def parse(value, *args, **kwargs):\n    json = _json.loads(value, *args, **kwargs)\n    wrapped = []\n    for value in json:\n        wrapped.append(_wrap(value))\n    input = []\n    for value in wrapped:\n        if isinstance(value, _String):\n            input.append(value.value)\n        else:",
        "detail": "front.node_modules.flatted.python.flatted",
        "documentation": {}
    },
    {
        "label": "stringify",
        "kind": 2,
        "importPath": "front.node_modules.flatted.python.flatted",
        "description": "front.node_modules.flatted.python.flatted",
        "peekOfCode": "def stringify(value, *args, **kwargs):\n    known = _Known()\n    input = []\n    output = []\n    i = int(_index(known, input, value))\n    while i < len(input):\n        output.append(_transform(known, input, input[i]))\n        i += 1\n    return _json.dumps(output, *args, **kwargs)",
        "detail": "front.node_modules.flatted.python.flatted",
        "documentation": {}
    },
    {
        "label": "stringify",
        "kind": 2,
        "importPath": "front.node_modules.flatted.python.test",
        "description": "front.node_modules.flatted.python.test",
        "peekOfCode": "def stringify(value):\n    return _stringify(value, separators=(',', ':'))\nassert stringify([None, None]) == '[[null,null]]'\na = []\no = {}\nassert stringify(a) == '[[]]'\nassert stringify(o) == '[{}]'\na.append(a)\no['o'] = o\nassert stringify(a) == '[[\"0\"]]'",
        "detail": "front.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "front.node_modules.flatted.python.test",
        "description": "front.node_modules.flatted.python.test",
        "peekOfCode": "a = []\no = {}\nassert stringify(a) == '[[]]'\nassert stringify(o) == '[{}]'\na.append(a)\no['o'] = o\nassert stringify(a) == '[[\"0\"]]'\nassert stringify(o) == '[{\"o\":\"0\"}]'\nb = parse(stringify(a))\nassert isinstance(b, list) and b[0] == b",
        "detail": "front.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "o",
        "kind": 5,
        "importPath": "front.node_modules.flatted.python.test",
        "description": "front.node_modules.flatted.python.test",
        "peekOfCode": "o = {}\nassert stringify(a) == '[[]]'\nassert stringify(o) == '[{}]'\na.append(a)\no['o'] = o\nassert stringify(a) == '[[\"0\"]]'\nassert stringify(o) == '[{\"o\":\"0\"}]'\nb = parse(stringify(a))\nassert isinstance(b, list) and b[0] == b\na.append(1)",
        "detail": "front.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "o['o']",
        "kind": 5,
        "importPath": "front.node_modules.flatted.python.test",
        "description": "front.node_modules.flatted.python.test",
        "peekOfCode": "o['o'] = o\nassert stringify(a) == '[[\"0\"]]'\nassert stringify(o) == '[{\"o\":\"0\"}]'\nb = parse(stringify(a))\nassert isinstance(b, list) and b[0] == b\na.append(1)\na.append('two')\na.append(True)\no['one'] = 1\no['two'] = 'two'",
        "detail": "front.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "front.node_modules.flatted.python.test",
        "description": "front.node_modules.flatted.python.test",
        "peekOfCode": "b = parse(stringify(a))\nassert isinstance(b, list) and b[0] == b\na.append(1)\na.append('two')\na.append(True)\no['one'] = 1\no['two'] = 'two'\no['three'] = True\nassert stringify(a) == '[[\"0\",1,\"1\",true],\"two\"]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true},\"two\"]'",
        "detail": "front.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "o['one']",
        "kind": 5,
        "importPath": "front.node_modules.flatted.python.test",
        "description": "front.node_modules.flatted.python.test",
        "peekOfCode": "o['one'] = 1\no['two'] = 'two'\no['three'] = True\nassert stringify(a) == '[[\"0\",1,\"1\",true],\"two\"]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true},\"two\"]'\na.append(o)\no['a'] = a\nassert stringify(a) == '[[\"0\",1,\"1\",true,\"2\"],\"two\",{\"o\":\"2\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"0\"}]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"2\"},\"two\",[\"2\",1,\"1\",true,\"0\"]]'\na.append({'test': 'OK'})",
        "detail": "front.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "o['two']",
        "kind": 5,
        "importPath": "front.node_modules.flatted.python.test",
        "description": "front.node_modules.flatted.python.test",
        "peekOfCode": "o['two'] = 'two'\no['three'] = True\nassert stringify(a) == '[[\"0\",1,\"1\",true],\"two\"]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true},\"two\"]'\na.append(o)\no['a'] = a\nassert stringify(a) == '[[\"0\",1,\"1\",true,\"2\"],\"two\",{\"o\":\"2\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"0\"}]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"2\"},\"two\",[\"2\",1,\"1\",true,\"0\"]]'\na.append({'test': 'OK'})\na.append([1, 2, 3])",
        "detail": "front.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "o['three']",
        "kind": 5,
        "importPath": "front.node_modules.flatted.python.test",
        "description": "front.node_modules.flatted.python.test",
        "peekOfCode": "o['three'] = True\nassert stringify(a) == '[[\"0\",1,\"1\",true],\"two\"]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true},\"two\"]'\na.append(o)\no['a'] = a\nassert stringify(a) == '[[\"0\",1,\"1\",true,\"2\"],\"two\",{\"o\":\"2\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"0\"}]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"2\"},\"two\",[\"2\",1,\"1\",true,\"0\"]]'\na.append({'test': 'OK'})\na.append([1, 2, 3])\no['test'] = {'test': 'OK'}",
        "detail": "front.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "o['a']",
        "kind": 5,
        "importPath": "front.node_modules.flatted.python.test",
        "description": "front.node_modules.flatted.python.test",
        "peekOfCode": "o['a'] = a\nassert stringify(a) == '[[\"0\",1,\"1\",true,\"2\"],\"two\",{\"o\":\"2\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"0\"}]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"2\"},\"two\",[\"2\",1,\"1\",true,\"0\"]]'\na.append({'test': 'OK'})\na.append([1, 2, 3])\no['test'] = {'test': 'OK'}\no['array'] = [1, 2, 3]\nassert stringify(a) == '[[\"0\",1,\"1\",true,\"2\",\"3\",\"4\"],\"two\",{\"o\":\"2\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"0\",\"test\":\"3\",\"array\":\"4\"},{\"test\":\"5\"},[1,2,3],\"OK\"]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"2\",\"test\":\"3\",\"array\":\"4\"},\"two\",[\"2\",1,\"1\",true,\"0\",\"3\",\"4\"],{\"test\":\"5\"},[1,2,3],\"OK\"]'\na2 = parse(stringify(a));",
        "detail": "front.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "o['test']",
        "kind": 5,
        "importPath": "front.node_modules.flatted.python.test",
        "description": "front.node_modules.flatted.python.test",
        "peekOfCode": "o['test'] = {'test': 'OK'}\no['array'] = [1, 2, 3]\nassert stringify(a) == '[[\"0\",1,\"1\",true,\"2\",\"3\",\"4\"],\"two\",{\"o\":\"2\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"0\",\"test\":\"3\",\"array\":\"4\"},{\"test\":\"5\"},[1,2,3],\"OK\"]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"2\",\"test\":\"3\",\"array\":\"4\"},\"two\",[\"2\",1,\"1\",true,\"0\",\"3\",\"4\"],{\"test\":\"5\"},[1,2,3],\"OK\"]'\na2 = parse(stringify(a));\no2 = parse(stringify(o));\nassert a2[0] == a2\nassert o2['o'] == o2\nassert a2[1] == 1 and a2[2] == 'two' and a2[3] == True and isinstance(a2[4], dict)\nassert a2[4] == a2[4]['o'] and a2 == a2[4]['o']['a']",
        "detail": "front.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "o['array']",
        "kind": 5,
        "importPath": "front.node_modules.flatted.python.test",
        "description": "front.node_modules.flatted.python.test",
        "peekOfCode": "o['array'] = [1, 2, 3]\nassert stringify(a) == '[[\"0\",1,\"1\",true,\"2\",\"3\",\"4\"],\"two\",{\"o\":\"2\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"0\",\"test\":\"3\",\"array\":\"4\"},{\"test\":\"5\"},[1,2,3],\"OK\"]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"2\",\"test\":\"3\",\"array\":\"4\"},\"two\",[\"2\",1,\"1\",true,\"0\",\"3\",\"4\"],{\"test\":\"5\"},[1,2,3],\"OK\"]'\na2 = parse(stringify(a));\no2 = parse(stringify(o));\nassert a2[0] == a2\nassert o2['o'] == o2\nassert a2[1] == 1 and a2[2] == 'two' and a2[3] == True and isinstance(a2[4], dict)\nassert a2[4] == a2[4]['o'] and a2 == a2[4]['o']['a']\nstr = parse('[{\"prop\":\"1\",\"a\":\"2\",\"b\":\"3\"},{\"value\":123},[\"4\",\"5\"],{\"e\":\"6\",\"t\":\"7\",\"p\":4},{},{\"b\":\"8\"},\"f\",{\"a\":\"9\"},[\"10\"],\"sup\",{\"a\":1,\"d\":2,\"c\":\"7\",\"z\":\"11\",\"h\":1},{\"g\":2,\"a\":\"7\",\"b\":\"12\",\"f\":6},{\"r\":4,\"u\":\"7\",\"c\":5}]')",
        "detail": "front.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "a2",
        "kind": 5,
        "importPath": "front.node_modules.flatted.python.test",
        "description": "front.node_modules.flatted.python.test",
        "peekOfCode": "a2 = parse(stringify(a));\no2 = parse(stringify(o));\nassert a2[0] == a2\nassert o2['o'] == o2\nassert a2[1] == 1 and a2[2] == 'two' and a2[3] == True and isinstance(a2[4], dict)\nassert a2[4] == a2[4]['o'] and a2 == a2[4]['o']['a']\nstr = parse('[{\"prop\":\"1\",\"a\":\"2\",\"b\":\"3\"},{\"value\":123},[\"4\",\"5\"],{\"e\":\"6\",\"t\":\"7\",\"p\":4},{},{\"b\":\"8\"},\"f\",{\"a\":\"9\"},[\"10\"],\"sup\",{\"a\":1,\"d\":2,\"c\":\"7\",\"z\":\"11\",\"h\":1},{\"g\":2,\"a\":\"7\",\"b\":\"12\",\"f\":6},{\"r\":4,\"u\":\"7\",\"c\":5}]')\nassert str['b']['t']['a'] == 'sup' and str['a'][1]['b'][0]['c'] == str['b']['t']\noo = parse('[{\"a\":\"1\",\"b\":\"0\",\"c\":\"2\"},{\"aa\":\"3\"},{\"ca\":\"4\",\"cb\":\"5\",\"cc\":\"6\",\"cd\":\"7\",\"ce\":\"8\",\"cf\":\"9\"},{\"aaa\":\"10\"},{\"caa\":\"4\"},{\"cba\":\"5\"},{\"cca\":\"2\"},{\"cda\":\"4\"},\"value2\",\"value3\",\"value1\"]');\nassert oo['a']['aa']['aaa'] == 'value1' and oo == oo['b'] and oo['c']['ca']['caa'] == oo['c']['ca']",
        "detail": "front.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "o2",
        "kind": 5,
        "importPath": "front.node_modules.flatted.python.test",
        "description": "front.node_modules.flatted.python.test",
        "peekOfCode": "o2 = parse(stringify(o));\nassert a2[0] == a2\nassert o2['o'] == o2\nassert a2[1] == 1 and a2[2] == 'two' and a2[3] == True and isinstance(a2[4], dict)\nassert a2[4] == a2[4]['o'] and a2 == a2[4]['o']['a']\nstr = parse('[{\"prop\":\"1\",\"a\":\"2\",\"b\":\"3\"},{\"value\":123},[\"4\",\"5\"],{\"e\":\"6\",\"t\":\"7\",\"p\":4},{},{\"b\":\"8\"},\"f\",{\"a\":\"9\"},[\"10\"],\"sup\",{\"a\":1,\"d\":2,\"c\":\"7\",\"z\":\"11\",\"h\":1},{\"g\":2,\"a\":\"7\",\"b\":\"12\",\"f\":6},{\"r\":4,\"u\":\"7\",\"c\":5}]')\nassert str['b']['t']['a'] == 'sup' and str['a'][1]['b'][0]['c'] == str['b']['t']\noo = parse('[{\"a\":\"1\",\"b\":\"0\",\"c\":\"2\"},{\"aa\":\"3\"},{\"ca\":\"4\",\"cb\":\"5\",\"cc\":\"6\",\"cd\":\"7\",\"ce\":\"8\",\"cf\":\"9\"},{\"aaa\":\"10\"},{\"caa\":\"4\"},{\"cba\":\"5\"},{\"cca\":\"2\"},{\"cda\":\"4\"},\"value2\",\"value3\",\"value1\"]');\nassert oo['a']['aa']['aaa'] == 'value1' and oo == oo['b'] and oo['c']['ca']['caa'] == oo['c']['ca']\nprint('OK')",
        "detail": "front.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "str",
        "kind": 5,
        "importPath": "front.node_modules.flatted.python.test",
        "description": "front.node_modules.flatted.python.test",
        "peekOfCode": "str = parse('[{\"prop\":\"1\",\"a\":\"2\",\"b\":\"3\"},{\"value\":123},[\"4\",\"5\"],{\"e\":\"6\",\"t\":\"7\",\"p\":4},{},{\"b\":\"8\"},\"f\",{\"a\":\"9\"},[\"10\"],\"sup\",{\"a\":1,\"d\":2,\"c\":\"7\",\"z\":\"11\",\"h\":1},{\"g\":2,\"a\":\"7\",\"b\":\"12\",\"f\":6},{\"r\":4,\"u\":\"7\",\"c\":5}]')\nassert str['b']['t']['a'] == 'sup' and str['a'][1]['b'][0]['c'] == str['b']['t']\noo = parse('[{\"a\":\"1\",\"b\":\"0\",\"c\":\"2\"},{\"aa\":\"3\"},{\"ca\":\"4\",\"cb\":\"5\",\"cc\":\"6\",\"cd\":\"7\",\"ce\":\"8\",\"cf\":\"9\"},{\"aaa\":\"10\"},{\"caa\":\"4\"},{\"cba\":\"5\"},{\"cca\":\"2\"},{\"cda\":\"4\"},\"value2\",\"value3\",\"value1\"]');\nassert oo['a']['aa']['aaa'] == 'value1' and oo == oo['b'] and oo['c']['ca']['caa'] == oo['c']['ca']\nprint('OK')",
        "detail": "front.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "oo",
        "kind": 5,
        "importPath": "front.node_modules.flatted.python.test",
        "description": "front.node_modules.flatted.python.test",
        "peekOfCode": "oo = parse('[{\"a\":\"1\",\"b\":\"0\",\"c\":\"2\"},{\"aa\":\"3\"},{\"ca\":\"4\",\"cb\":\"5\",\"cc\":\"6\",\"cd\":\"7\",\"ce\":\"8\",\"cf\":\"9\"},{\"aaa\":\"10\"},{\"caa\":\"4\"},{\"cba\":\"5\"},{\"cca\":\"2\"},{\"cda\":\"4\"},\"value2\",\"value3\",\"value1\"]');\nassert oo['a']['aa']['aaa'] == 'value1' and oo == oo['b'] and oo['c']['ca']['caa'] == oo['c']['ca']\nprint('OK')",
        "detail": "front.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "B4SD",
        "kind": 6,
        "importPath": "project.actuators.b4sd",
        "description": "project.actuators.b4sd",
        "peekOfCode": "class B4SD:\n    def __init__(self, settings):\n        # GPIO ports for the 7seg pins\n        self.segments = settings[\"segments\"]\n        for segment in self.segments:\n            GPIO.setup(segment, GPIO.OUT)\n            GPIO.output(segment, 0)\n        self.digits = settings[\"digits\"]\n        for digit in self.digits:\n            GPIO.setup(digit, GPIO.OUT)",
        "detail": "project.actuators.b4sd",
        "documentation": {}
    },
    {
        "label": "on_connect",
        "kind": 2,
        "importPath": "project.actuators.b4sd",
        "description": "project.actuators.b4sd",
        "peekOfCode": "def on_connect(client, userdata, flags, rc):\n    client.subscribe(\"front-bb-on\")\n    client.subscribe(\"front-bb-off\")\ndef update_data(topic, data):\n    global delay\n    print(\"bb data: \", data, \"received from topic \" + topic)\n    if topic == \"front-bb-on\":\n        delay = 0.5\n    elif topic == \"front-bb-off\":\n        delay = 0.001",
        "detail": "project.actuators.b4sd",
        "documentation": {}
    },
    {
        "label": "update_data",
        "kind": 2,
        "importPath": "project.actuators.b4sd",
        "description": "project.actuators.b4sd",
        "peekOfCode": "def update_data(topic, data):\n    global delay\n    print(\"bb data: \", data, \"received from topic \" + topic)\n    if topic == \"front-bb-on\":\n        delay = 0.5\n    elif topic == \"front-bb-off\":\n        delay = 0.001\ndef connect_mqtt(hostname,port):\n    mqtt_client = mqtt.Client()\n    mqtt_client.connect(hostname, port, 60)",
        "detail": "project.actuators.b4sd",
        "documentation": {}
    },
    {
        "label": "connect_mqtt",
        "kind": 2,
        "importPath": "project.actuators.b4sd",
        "description": "project.actuators.b4sd",
        "peekOfCode": "def connect_mqtt(hostname,port):\n    mqtt_client = mqtt.Client()\n    mqtt_client.connect(hostname, port, 60)\n    mqtt_client.loop_start()\n    mqtt_client.on_connect = on_connect\n    mqtt_client.on_message = lambda client, userdata, msg: update_data(msg.topic, json.loads(msg.payload.decode('utf-8')))\nclass B4SD:\n    def __init__(self, settings):\n        # GPIO ports for the 7seg pins\n        self.segments = settings[\"segments\"]",
        "detail": "project.actuators.b4sd",
        "documentation": {}
    },
    {
        "label": "run_b4sd_loop",
        "kind": 2,
        "importPath": "project.actuators.b4sd",
        "description": "project.actuators.b4sd",
        "peekOfCode": "def run_b4sd_loop(b4sd, delay, callback, stop_event, publish_event, settings,hostname,port):\n    connect_mqtt(hostname,port)\n    while True:\n        value = b4sd.show_value()\n        callback(value, publish_event, settings)\n        if stop_event.is_set():\n            GPIO.cleanup()\n            break",
        "detail": "project.actuators.b4sd",
        "documentation": {}
    },
    {
        "label": "delay",
        "kind": 5,
        "importPath": "project.actuators.b4sd",
        "description": "project.actuators.b4sd",
        "peekOfCode": "delay = 0.001\ndef on_connect(client, userdata, flags, rc):\n    client.subscribe(\"front-bb-on\")\n    client.subscribe(\"front-bb-off\")\ndef update_data(topic, data):\n    global delay\n    print(\"bb data: \", data, \"received from topic \" + topic)\n    if topic == \"front-bb-on\":\n        delay = 0.5\n    elif topic == \"front-bb-off\":",
        "detail": "project.actuators.b4sd",
        "documentation": {}
    },
    {
        "label": "Buzzer",
        "kind": 6,
        "importPath": "project.actuators.buzzer",
        "description": "project.actuators.buzzer",
        "peekOfCode": "class Buzzer:\n    def __init__(self, name, pin):\n        self.name = name\n        self.pin = pin\n        self.interrupt = Queue()\n        GPIO.setmode(GPIO.BCM)\n        GPIO.setup(self.pin, GPIO.OUT)\n    def turn_on(self):\n        GPIO.output(self.pin, GPIO.HIGH)\n    def turn_off(self):",
        "detail": "project.actuators.buzzer",
        "documentation": {}
    },
    {
        "label": "run_db_loop",
        "kind": 2,
        "importPath": "project.actuators.buzzer",
        "description": "project.actuators.buzzer",
        "peekOfCode": "def run_db_loop(should_turn_on_db, should_turn_on_bb, input_queue, db, delay, callback, stop_event, name, runsOn, melody, durations):\n    alarm_on = False\n    queue_to_use = should_turn_on_db if name == \"DB\" else should_turn_on_bb\n    print(f\"Starting {name} loop\")\n    while not stop_event.is_set():\n        if not queue_to_use.empty():\n            alarm_on = queue_to_use.get()\n            if alarm_on:\n                db.turn_on()\n            else:",
        "detail": "project.actuators.buzzer",
        "documentation": {}
    },
    {
        "label": "NOTES",
        "kind": 5,
        "importPath": "project.actuators.buzzer",
        "description": "project.actuators.buzzer",
        "peekOfCode": "NOTES = {\n    'cL': 129, 'cLS': 139, 'dL': 146, 'dLS': 156, 'eL': 163, 'fL': 173,\n    'fLS': 185, 'gL': 194, 'gLS': 207, 'aL': 219, 'aLS': 228, 'bL': 232,\n    'c': 261, 'cS': 277, 'd': 294, 'dS': 311, 'e': 329, 'f': 349,\n    'fS': 370, 'g': 391, 'gS': 415, 'a': 440, 'aS': 455, 'b': 466,\n    'cH': 523, 'cHS': 554, 'dH': 587, 'dHS': 622, 'eH': 659, 'fH': 698,\n    'fHS': 740, 'gH': 784, 'gHS': 830, 'aH': 880, 'aHS': 910, 'bH': 933\n}\nclass Buzzer:\n    def __init__(self, name, pin):",
        "detail": "project.actuators.buzzer",
        "documentation": {}
    },
    {
        "label": "Dioda",
        "kind": 6,
        "importPath": "project.actuators.dioda",
        "description": "project.actuators.dioda",
        "peekOfCode": "class Dioda:\n    def __init__(self, name, pin):\n        self.pin = int(pin)\n        self.name = name\n        self.is_on = False\n        GPIO.setup(self.pin, GPIO.OUT)\n    def switch_light(self):\n        self.is_on = not self.is_on\n        if self.is_on:\n            GPIO.output(self.pin, GPIO.HIGH)",
        "detail": "project.actuators.dioda",
        "documentation": {}
    },
    {
        "label": "run_dioda_loop",
        "kind": 2,
        "importPath": "project.actuators.dioda",
        "description": "project.actuators.dioda",
        "peekOfCode": "def run_dioda_loop(pipe, dioda, delay, callback, stop_event, publish_event, settings):\n    last_dioda_time = time.time()\n    while True:\n        if pipe.poll():\n            message = pipe.recv()\n            message = str(message).strip().lower()\n            if message == \"l\":\n                last_dioda_time = time.time()\n        dioda.is_on = time.time() - last_dioda_time <= 10\n        callback(dioda.is_on, publish_event, settings)",
        "detail": "project.actuators.dioda",
        "documentation": {}
    },
    {
        "label": "RGB",
        "kind": 6,
        "importPath": "project.actuators.rgb",
        "description": "project.actuators.rgb",
        "peekOfCode": "class RGB:\n    def __init__(self, settings,hostname,port):\n        self.red_pin = settings['red_pin']\n        self.blue_pin = settings['blue_pin']\n        self.green_pin = settings['green_pin']\n        self.status = \"off\"\n        self.name = settings['name']\n        GPIO.setup(self.red_pin, GPIO.OUT)\n        GPIO.setup(self.blue_pin, GPIO.OUT)\n        GPIO.setup(self.green_pin, GPIO.OUT)",
        "detail": "project.actuators.rgb",
        "documentation": {}
    },
    {
        "label": "change_color",
        "kind": 2,
        "importPath": "project.actuators.rgb",
        "description": "project.actuators.rgb",
        "peekOfCode": "def change_color(key):\n    if key == \"1\":\n        return \"red\"\n    elif key == \"2\":\n        return \"green\"\n    elif key == \"3\":\n        return \"blue\"\n    elif key == \"4\":\n        return \"yellow\"\n    elif key == \"5\":",
        "detail": "project.actuators.rgb",
        "documentation": {}
    },
    {
        "label": "on_connect",
        "kind": 2,
        "importPath": "project.actuators.rgb",
        "description": "project.actuators.rgb",
        "peekOfCode": "def on_connect(client, userdata, flags, rc):\n    client.subscribe(\"data/ir\")\n    client.subscribe(\"change/rgb\")\n    client.subscribe(\"front-rgb\")\ndef update_data(topic, data):\n    global new_action\n    print(\"rgb data: \", data, \"received from topic \" + topic)\n    new_action = change_color(data[\"value\"])\ndef connect_mqtt(hostname,port):\n    mqtt_client = mqtt.Client()",
        "detail": "project.actuators.rgb",
        "documentation": {}
    },
    {
        "label": "update_data",
        "kind": 2,
        "importPath": "project.actuators.rgb",
        "description": "project.actuators.rgb",
        "peekOfCode": "def update_data(topic, data):\n    global new_action\n    print(\"rgb data: \", data, \"received from topic \" + topic)\n    new_action = change_color(data[\"value\"])\ndef connect_mqtt(hostname,port):\n    mqtt_client = mqtt.Client()\n    mqtt_client.connect(hostname, port, 60)\n    mqtt_client.loop_start()\n    mqtt_client.on_connect = on_connect\n    mqtt_client.on_message = lambda client, userdata, msg: update_data(msg.topic, json.loads(msg.payload.decode('utf-8')))",
        "detail": "project.actuators.rgb",
        "documentation": {}
    },
    {
        "label": "connect_mqtt",
        "kind": 2,
        "importPath": "project.actuators.rgb",
        "description": "project.actuators.rgb",
        "peekOfCode": "def connect_mqtt(hostname,port):\n    mqtt_client = mqtt.Client()\n    mqtt_client.connect(hostname, port, 60)\n    mqtt_client.loop_start()\n    mqtt_client.on_connect = on_connect\n    mqtt_client.on_message = lambda client, userdata, msg: update_data(msg.topic, json.loads(msg.payload.decode('utf-8')))\nclass RGB:\n    def __init__(self, settings,hostname,port):\n        self.red_pin = settings['red_pin']\n        self.blue_pin = settings['blue_pin']",
        "detail": "project.actuators.rgb",
        "documentation": {}
    },
    {
        "label": "change_light",
        "kind": 2,
        "importPath": "project.actuators.rgb",
        "description": "project.actuators.rgb",
        "peekOfCode": "def change_light(rgb):\n    if rgb.status == \"red\":\n        rgb.red()\n    elif rgb.status == \"blue\":\n        rgb.blue()\n    elif rgb.status == \"green\":\n        rgb.green()\n    elif rgb.status == \"yellow\":\n        rgb.yellow()\n    elif rgb.status == \"purple\":",
        "detail": "project.actuators.rgb",
        "documentation": {}
    },
    {
        "label": "run_rgb_loop",
        "kind": 2,
        "importPath": "project.actuators.rgb",
        "description": "project.actuators.rgb",
        "peekOfCode": "def run_rgb_loop(rgb, delay, callback, stop_event, publish_event, settings,hostname,port):\n    connect_mqtt(hostname, port)\n    rgb.turnOff()\n    while True:\n        if new_action != rgb.status:\n            rgb.status = new_action\n            change_light(rgb)\n            callback(rgb.status, publish_event, settings)\n        if stop_event.is_set():\n            GPIO.cleanup()",
        "detail": "project.actuators.rgb",
        "documentation": {}
    },
    {
        "label": "new_action",
        "kind": 5,
        "importPath": "project.actuators.rgb",
        "description": "project.actuators.rgb",
        "peekOfCode": "new_action = \"off\"\ndef change_color(key):\n    if key == \"1\":\n        return \"red\"\n    elif key == \"2\":\n        return \"green\"\n    elif key == \"3\":\n        return \"blue\"\n    elif key == \"4\":\n        return \"yellow\"",
        "detail": "project.actuators.rgb",
        "documentation": {}
    },
    {
        "label": "publisher_task",
        "kind": 2,
        "importPath": "project.components.IR",
        "description": "project.components.IR",
        "peekOfCode": "def publisher_task(event, ir_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_ir_batch = ir_batch.copy()\n            publish_data_counter = 0\n            ir_batch.clear()\n        publish.multiple(local_ir_batch, hostname=HOSTNAME, port=PORT)\n        print(f'Published {publish_data_limit} infrared values')",
        "detail": "project.components.IR",
        "documentation": {}
    },
    {
        "label": "ir_callback",
        "kind": 2,
        "importPath": "project.components.IR",
        "description": "project.components.IR",
        "peekOfCode": "def ir_callback(key, publish_event, ir_settings, verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + ir_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")\n        print(f\"Key pressed: {key}\")\n    payload = {\n        \"measurement\": \"Infrared\",\n        \"simulated\": ir_settings['simulated'],",
        "detail": "project.components.IR",
        "documentation": {}
    },
    {
        "label": "run_infrared",
        "kind": 2,
        "importPath": "project.components.IR",
        "description": "project.components.IR",
        "peekOfCode": "def run_infrared(settings, threads, stop_event):\n    if settings['simulated']:\n        print(\"Starting {} simulator\".format(settings[\"name\"]))\n        ir_thread = threading.Thread(target=run_ir_simulator,\n                                      args=(10, ir_callback, stop_event, publish_event, settings))\n        ir_thread.start()\n        threads.append(ir_thread)\n        print(\"{0} simulator started\".format(settings[\"name\"]))\n    else:\n        from sensors.infrared import run_ir_loop, Infrared",
        "detail": "project.components.IR",
        "documentation": {}
    },
    {
        "label": "ir_batch",
        "kind": 5,
        "importPath": "project.components.IR",
        "description": "project.components.IR",
        "peekOfCode": "ir_batch = []\npublish_data_counter = 0\npublish_data_limit = 1\ncounter_lock = threading.Lock()\ndef publisher_task(event, ir_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_ir_batch = ir_batch.copy()",
        "detail": "project.components.IR",
        "documentation": {}
    },
    {
        "label": "publish_data_counter",
        "kind": 5,
        "importPath": "project.components.IR",
        "description": "project.components.IR",
        "peekOfCode": "publish_data_counter = 0\npublish_data_limit = 1\ncounter_lock = threading.Lock()\ndef publisher_task(event, ir_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_ir_batch = ir_batch.copy()\n            publish_data_counter = 0",
        "detail": "project.components.IR",
        "documentation": {}
    },
    {
        "label": "publish_data_limit",
        "kind": 5,
        "importPath": "project.components.IR",
        "description": "project.components.IR",
        "peekOfCode": "publish_data_limit = 1\ncounter_lock = threading.Lock()\ndef publisher_task(event, ir_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_ir_batch = ir_batch.copy()\n            publish_data_counter = 0\n            ir_batch.clear()",
        "detail": "project.components.IR",
        "documentation": {}
    },
    {
        "label": "counter_lock",
        "kind": 5,
        "importPath": "project.components.IR",
        "description": "project.components.IR",
        "peekOfCode": "counter_lock = threading.Lock()\ndef publisher_task(event, ir_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_ir_batch = ir_batch.copy()\n            publish_data_counter = 0\n            ir_batch.clear()\n        publish.multiple(local_ir_batch, hostname=HOSTNAME, port=PORT)",
        "detail": "project.components.IR",
        "documentation": {}
    },
    {
        "label": "publish_event",
        "kind": 5,
        "importPath": "project.components.IR",
        "description": "project.components.IR",
        "peekOfCode": "publish_event = threading.Event()\npublisher_thread = threading.Thread(target=publisher_task, args=(publish_event, ir_batch,))\npublisher_thread.daemon = True\npublisher_thread.start()\ndef ir_callback(key, publish_event, ir_settings, verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + ir_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")",
        "detail": "project.components.IR",
        "documentation": {}
    },
    {
        "label": "publisher_thread",
        "kind": 5,
        "importPath": "project.components.IR",
        "description": "project.components.IR",
        "peekOfCode": "publisher_thread = threading.Thread(target=publisher_task, args=(publish_event, ir_batch,))\npublisher_thread.daemon = True\npublisher_thread.start()\ndef ir_callback(key, publish_event, ir_settings, verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + ir_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")\n        print(f\"Key pressed: {key}\")",
        "detail": "project.components.IR",
        "documentation": {}
    },
    {
        "label": "publisher_thread.daemon",
        "kind": 5,
        "importPath": "project.components.IR",
        "description": "project.components.IR",
        "peekOfCode": "publisher_thread.daemon = True\npublisher_thread.start()\ndef ir_callback(key, publish_event, ir_settings, verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + ir_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")\n        print(f\"Key pressed: {key}\")\n    payload = {",
        "detail": "project.components.IR",
        "documentation": {}
    },
    {
        "label": "publisher_task",
        "kind": 2,
        "importPath": "project.components.b4sd",
        "description": "project.components.b4sd",
        "peekOfCode": "def publisher_task(event, b4sd_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_rgb_batch = b4sd_batch.copy()\n            publish_data_counter = 0\n            b4sd_batch.clear()\n        publish.multiple(local_rgb_batch, hostname=HOSTNAME, port=PORT)\n        print(f'Showed {publish_data_limit} b4sd values')",
        "detail": "project.components.b4sd",
        "documentation": {}
    },
    {
        "label": "b4sd_callback",
        "kind": 2,
        "importPath": "project.components.b4sd",
        "description": "project.components.b4sd",
        "peekOfCode": "def b4sd_callback(time_value, publish_event, b4sd_settings, verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + b4sd_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")\n        print(f\"Time: {time_value}\")\n    payload = {\n        \"measurement\": \"Time_b4sd\",\n        \"simulated\": b4sd_settings['simulated'],",
        "detail": "project.components.b4sd",
        "documentation": {}
    },
    {
        "label": "run_b4sd",
        "kind": 2,
        "importPath": "project.components.b4sd",
        "description": "project.components.b4sd",
        "peekOfCode": "def run_b4sd(settings, threads, stop_event,hostname,port):\n    if settings['simulated']:\n        print(\"Starting {} simulator\".format(settings[\"name\"]))\n        b4sd_thread = threading.Thread(target=run_b4sd_simulator, args=(2, b4sd_callback, stop_event, publish_event, settings))\n        b4sd_thread.start()\n        threads.append(b4sd_thread)\n        print(\"{0} simulator started\".format(settings[\"name\"]))\n    else:\n        from sensors.b4sd import run_b4sd_loop, B4SD\n        print(\"Starting {} loop\".format(settings[\"name\"]))",
        "detail": "project.components.b4sd",
        "documentation": {}
    },
    {
        "label": "b4sd_batch",
        "kind": 5,
        "importPath": "project.components.b4sd",
        "description": "project.components.b4sd",
        "peekOfCode": "b4sd_batch = []\npublish_data_counter = 0\npublish_data_limit = 4\ncounter_lock = threading.Lock()\ndef publisher_task(event, b4sd_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_rgb_batch = b4sd_batch.copy()",
        "detail": "project.components.b4sd",
        "documentation": {}
    },
    {
        "label": "publish_data_counter",
        "kind": 5,
        "importPath": "project.components.b4sd",
        "description": "project.components.b4sd",
        "peekOfCode": "publish_data_counter = 0\npublish_data_limit = 4\ncounter_lock = threading.Lock()\ndef publisher_task(event, b4sd_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_rgb_batch = b4sd_batch.copy()\n            publish_data_counter = 0",
        "detail": "project.components.b4sd",
        "documentation": {}
    },
    {
        "label": "publish_data_limit",
        "kind": 5,
        "importPath": "project.components.b4sd",
        "description": "project.components.b4sd",
        "peekOfCode": "publish_data_limit = 4\ncounter_lock = threading.Lock()\ndef publisher_task(event, b4sd_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_rgb_batch = b4sd_batch.copy()\n            publish_data_counter = 0\n            b4sd_batch.clear()",
        "detail": "project.components.b4sd",
        "documentation": {}
    },
    {
        "label": "counter_lock",
        "kind": 5,
        "importPath": "project.components.b4sd",
        "description": "project.components.b4sd",
        "peekOfCode": "counter_lock = threading.Lock()\ndef publisher_task(event, b4sd_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_rgb_batch = b4sd_batch.copy()\n            publish_data_counter = 0\n            b4sd_batch.clear()\n        publish.multiple(local_rgb_batch, hostname=HOSTNAME, port=PORT)",
        "detail": "project.components.b4sd",
        "documentation": {}
    },
    {
        "label": "publish_event",
        "kind": 5,
        "importPath": "project.components.b4sd",
        "description": "project.components.b4sd",
        "peekOfCode": "publish_event = threading.Event()\npublisher_thread = threading.Thread(target=publisher_task, args=(publish_event, b4sd_batch,))\npublisher_thread.daemon = True\npublisher_thread.start()\ndef b4sd_callback(time_value, publish_event, b4sd_settings, verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + b4sd_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")",
        "detail": "project.components.b4sd",
        "documentation": {}
    },
    {
        "label": "publisher_thread",
        "kind": 5,
        "importPath": "project.components.b4sd",
        "description": "project.components.b4sd",
        "peekOfCode": "publisher_thread = threading.Thread(target=publisher_task, args=(publish_event, b4sd_batch,))\npublisher_thread.daemon = True\npublisher_thread.start()\ndef b4sd_callback(time_value, publish_event, b4sd_settings, verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + b4sd_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")\n        print(f\"Time: {time_value}\")",
        "detail": "project.components.b4sd",
        "documentation": {}
    },
    {
        "label": "publisher_thread.daemon",
        "kind": 5,
        "importPath": "project.components.b4sd",
        "description": "project.components.b4sd",
        "peekOfCode": "publisher_thread.daemon = True\npublisher_thread.start()\ndef b4sd_callback(time_value, publish_event, b4sd_settings, verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + b4sd_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")\n        print(f\"Time: {time_value}\")\n    payload = {",
        "detail": "project.components.b4sd",
        "documentation": {}
    },
    {
        "label": "publisher_task",
        "kind": 2,
        "importPath": "project.components.button",
        "description": "project.components.button",
        "peekOfCode": "def publisher_task(event, button_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_dht_batch = button_batch.copy()\n            publish_data_counter = 0\n            button_batch.clear()\n        publish.multiple(local_dht_batch, hostname=HOSTNAME, port=PORT)\n        print(f'Published {publish_data_limit} button values')",
        "detail": "project.components.button",
        "documentation": {}
    },
    {
        "label": "button_pressed",
        "kind": 2,
        "importPath": "project.components.button",
        "description": "project.components.button",
        "peekOfCode": "def button_pressed(publish_event, dht_settings, verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + dht_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")\n        print(\"The door are OPENED\")\n    payload = {\n        \"measurement\": \"Button_pressed\",\n        \"simulated\": dht_settings['simulated'],",
        "detail": "project.components.button",
        "documentation": {}
    },
    {
        "label": "button_released",
        "kind": 2,
        "importPath": "project.components.button",
        "description": "project.components.button",
        "peekOfCode": "def button_released(publish_event, dht_settings, verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + dht_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")\n        print(\"The door are CLOSED\")\n    payload = {\n        \"measurement\": \"Button_pressed\",\n        \"simulated\": dht_settings['simulated'],",
        "detail": "project.components.button",
        "documentation": {}
    },
    {
        "label": "run_button",
        "kind": 2,
        "importPath": "project.components.button",
        "description": "project.components.button",
        "peekOfCode": "def run_button(settings, threads, stop_event):\n    if settings['simulated']:\n        print(\"Starting {} simulator\".format(settings[\"name\"]))\n        button_thread = threading.Thread(target=run_button_simulator, args=(2, button_pressed, button_released, stop_event, publish_event, settings))\n        button_thread.start()\n        threads.append(button_thread)\n        print(\"{0} simulator started\".format(settings[\"name\"]))\n    else:\n        from sensors.button import run_button_loop, Button\n        print(\"Starting {} loop\".format(settings[\"name\"]))",
        "detail": "project.components.button",
        "documentation": {}
    },
    {
        "label": "button_batch",
        "kind": 5,
        "importPath": "project.components.button",
        "description": "project.components.button",
        "peekOfCode": "button_batch = []\npublish_data_counter = 0\npublish_data_limit = 3\ncounter_lock = threading.Lock()\ndef publisher_task(event, button_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_dht_batch = button_batch.copy()",
        "detail": "project.components.button",
        "documentation": {}
    },
    {
        "label": "publish_data_counter",
        "kind": 5,
        "importPath": "project.components.button",
        "description": "project.components.button",
        "peekOfCode": "publish_data_counter = 0\npublish_data_limit = 3\ncounter_lock = threading.Lock()\ndef publisher_task(event, button_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_dht_batch = button_batch.copy()\n            publish_data_counter = 0",
        "detail": "project.components.button",
        "documentation": {}
    },
    {
        "label": "publish_data_limit",
        "kind": 5,
        "importPath": "project.components.button",
        "description": "project.components.button",
        "peekOfCode": "publish_data_limit = 3\ncounter_lock = threading.Lock()\ndef publisher_task(event, button_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_dht_batch = button_batch.copy()\n            publish_data_counter = 0\n            button_batch.clear()",
        "detail": "project.components.button",
        "documentation": {}
    },
    {
        "label": "counter_lock",
        "kind": 5,
        "importPath": "project.components.button",
        "description": "project.components.button",
        "peekOfCode": "counter_lock = threading.Lock()\ndef publisher_task(event, button_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_dht_batch = button_batch.copy()\n            publish_data_counter = 0\n            button_batch.clear()\n        publish.multiple(local_dht_batch, hostname=HOSTNAME, port=PORT)",
        "detail": "project.components.button",
        "documentation": {}
    },
    {
        "label": "publish_event",
        "kind": 5,
        "importPath": "project.components.button",
        "description": "project.components.button",
        "peekOfCode": "publish_event = threading.Event()\npublisher_thread = threading.Thread(target=publisher_task, args=(publish_event, button_batch,))\npublisher_thread.daemon = True\npublisher_thread.start()\ndef button_pressed(publish_event, dht_settings, verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + dht_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")",
        "detail": "project.components.button",
        "documentation": {}
    },
    {
        "label": "publisher_thread",
        "kind": 5,
        "importPath": "project.components.button",
        "description": "project.components.button",
        "peekOfCode": "publisher_thread = threading.Thread(target=publisher_task, args=(publish_event, button_batch,))\npublisher_thread.daemon = True\npublisher_thread.start()\ndef button_pressed(publish_event, dht_settings, verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + dht_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")\n        print(\"The door are OPENED\")",
        "detail": "project.components.button",
        "documentation": {}
    },
    {
        "label": "publisher_thread.daemon",
        "kind": 5,
        "importPath": "project.components.button",
        "description": "project.components.button",
        "peekOfCode": "publisher_thread.daemon = True\npublisher_thread.start()\ndef button_pressed(publish_event, dht_settings, verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + dht_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")\n        print(\"The door are OPENED\")\n    payload = {",
        "detail": "project.components.button",
        "documentation": {}
    },
    {
        "label": "publisher_task",
        "kind": 2,
        "importPath": "project.components.buzzer",
        "description": "project.components.buzzer",
        "peekOfCode": "def publisher_task(event, buzzer_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_dht_batch = buzzer_batch.copy()\n            publish_data_counter = 0\n            buzzer_batch.clear()\n        publish.multiple(local_dht_batch, hostname=HOSTNAME, port=PORT)\n        print(f'Published {publish_data_limit} buzzer values')",
        "detail": "project.components.buzzer",
        "documentation": {}
    },
    {
        "label": "buzzer_activated",
        "kind": 2,
        "importPath": "project.components.buzzer",
        "description": "project.components.buzzer",
        "peekOfCode": "def buzzer_activated(publish_event, buzzer_settings, verbose=False):\n    global publish_data_counter, publish_data_limit\n    measurement = \"bedroom_buzzer\" if buzzer_settings[\"name\"] == \"BB\" else \"Buzzer_active\"\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + buzzer_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")\n        print(\"Buzzer activated\")\n    payload = {\n        \"measurement\": measurement,",
        "detail": "project.components.buzzer",
        "documentation": {}
    },
    {
        "label": "buzzer_deactivated",
        "kind": 2,
        "importPath": "project.components.buzzer",
        "description": "project.components.buzzer",
        "peekOfCode": "def buzzer_deactivated(publish_event, buzzer_settings, verbose=False):\n    global publish_data_counter, publish_data_limit\n    measurement = \"bedroom_buzzer\" if buzzer_settings[\"name\"] == \"BB\" else \"Buzzer_active\"\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + buzzer_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")\n        print(\"Buzzer deactivated\")\n    payload = {\n        \"measurement\": measurement,",
        "detail": "project.components.buzzer",
        "documentation": {}
    },
    {
        "label": "run_buzzer",
        "kind": 2,
        "importPath": "project.components.buzzer",
        "description": "project.components.buzzer",
        "peekOfCode": "def run_buzzer(settings, threads, stop_event):\n    if settings['simulated']:\n        print(\"Starting {} simulator\".format(settings[\"name\"]))\n        buzzer_thread = threading.Thread(target=run_buzzer_simulator, args=(2, buzzer_activated, buzzer_deactivated,\n                                                                            stop_event, publish_event, settings))\n        buzzer_thread.start()\n        threads.append(buzzer_thread)\n        print(\"{0} simulator started\".format(settings[\"name\"]))\n    else:\n        from sensors.buzzer import run_buzzer_sensor, Buzzer",
        "detail": "project.components.buzzer",
        "documentation": {}
    },
    {
        "label": "buzzer_batch",
        "kind": 5,
        "importPath": "project.components.buzzer",
        "description": "project.components.buzzer",
        "peekOfCode": "buzzer_batch = []\npublish_data_counter = 0\npublish_data_limit = 1\ncounter_lock = threading.Lock()\ndef publisher_task(event, buzzer_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_dht_batch = buzzer_batch.copy()",
        "detail": "project.components.buzzer",
        "documentation": {}
    },
    {
        "label": "publish_data_counter",
        "kind": 5,
        "importPath": "project.components.buzzer",
        "description": "project.components.buzzer",
        "peekOfCode": "publish_data_counter = 0\npublish_data_limit = 1\ncounter_lock = threading.Lock()\ndef publisher_task(event, buzzer_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_dht_batch = buzzer_batch.copy()\n            publish_data_counter = 0",
        "detail": "project.components.buzzer",
        "documentation": {}
    },
    {
        "label": "publish_data_limit",
        "kind": 5,
        "importPath": "project.components.buzzer",
        "description": "project.components.buzzer",
        "peekOfCode": "publish_data_limit = 1\ncounter_lock = threading.Lock()\ndef publisher_task(event, buzzer_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_dht_batch = buzzer_batch.copy()\n            publish_data_counter = 0\n            buzzer_batch.clear()",
        "detail": "project.components.buzzer",
        "documentation": {}
    },
    {
        "label": "counter_lock",
        "kind": 5,
        "importPath": "project.components.buzzer",
        "description": "project.components.buzzer",
        "peekOfCode": "counter_lock = threading.Lock()\ndef publisher_task(event, buzzer_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_dht_batch = buzzer_batch.copy()\n            publish_data_counter = 0\n            buzzer_batch.clear()\n        publish.multiple(local_dht_batch, hostname=HOSTNAME, port=PORT)",
        "detail": "project.components.buzzer",
        "documentation": {}
    },
    {
        "label": "publish_event",
        "kind": 5,
        "importPath": "project.components.buzzer",
        "description": "project.components.buzzer",
        "peekOfCode": "publish_event = threading.Event()\npublisher_thread = threading.Thread(target=publisher_task, args=(publish_event, buzzer_batch,))\npublisher_thread.daemon = True\npublisher_thread.start()\ndef buzzer_activated(publish_event, buzzer_settings, verbose=False):\n    global publish_data_counter, publish_data_limit\n    measurement = \"bedroom_buzzer\" if buzzer_settings[\"name\"] == \"BB\" else \"Buzzer_active\"\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + buzzer_settings[\"name\"] + \"=\" * 10)",
        "detail": "project.components.buzzer",
        "documentation": {}
    },
    {
        "label": "publisher_thread",
        "kind": 5,
        "importPath": "project.components.buzzer",
        "description": "project.components.buzzer",
        "peekOfCode": "publisher_thread = threading.Thread(target=publisher_task, args=(publish_event, buzzer_batch,))\npublisher_thread.daemon = True\npublisher_thread.start()\ndef buzzer_activated(publish_event, buzzer_settings, verbose=False):\n    global publish_data_counter, publish_data_limit\n    measurement = \"bedroom_buzzer\" if buzzer_settings[\"name\"] == \"BB\" else \"Buzzer_active\"\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + buzzer_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")",
        "detail": "project.components.buzzer",
        "documentation": {}
    },
    {
        "label": "publisher_thread.daemon",
        "kind": 5,
        "importPath": "project.components.buzzer",
        "description": "project.components.buzzer",
        "peekOfCode": "publisher_thread.daemon = True\npublisher_thread.start()\ndef buzzer_activated(publish_event, buzzer_settings, verbose=False):\n    global publish_data_counter, publish_data_limit\n    measurement = \"bedroom_buzzer\" if buzzer_settings[\"name\"] == \"BB\" else \"Buzzer_active\"\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + buzzer_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")\n        print(\"Buzzer activated\")",
        "detail": "project.components.buzzer",
        "documentation": {}
    },
    {
        "label": "publisher_task",
        "kind": 2,
        "importPath": "project.components.dht",
        "description": "project.components.dht",
        "peekOfCode": "def publisher_task(event, dht_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_dht_batch = dht_batch.copy()\n            publish_data_counter = 0\n            dht_batch.clear()\n        publish.multiple(local_dht_batch, hostname=HOSTNAME, port=PORT)\n        print(f'Published {publish_data_limit} dht values')",
        "detail": "project.components.dht",
        "documentation": {}
    },
    {
        "label": "dht_callback",
        "kind": 2,
        "importPath": "project.components.dht",
        "description": "project.components.dht",
        "peekOfCode": "def dht_callback(humidity, temperature, publish_event, dht_settings, code=\"DHTLIB_OK\", verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + dht_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")\n        print(f\"Code: {code}\")\n        print(f\"Humidity: {humidity}%\")\n        print(f\"Temperature: {temperature}C\")\n    temp_payload = {",
        "detail": "project.components.dht",
        "documentation": {}
    },
    {
        "label": "run_dht",
        "kind": 2,
        "importPath": "project.components.dht",
        "description": "project.components.dht",
        "peekOfCode": "def run_dht(settings, threads, stop_event):\n    if settings['simulated']:\n        print(\"Starting {} simulator\".format(settings[\"name\"]))\n        dht1_thread = threading.Thread(target=run_dht_simulator, args=(2, dht_callback, stop_event, publish_event, settings))\n        dht1_thread.start()\n        threads.append(dht1_thread)\n        print(\"{0} simulator started\".format(settings[\"name\"]))\n    else:\n        from sensors.dht import run_dht_loop, DHT\n        print(\"Starting {} loop\".format(settings[\"name\"]))",
        "detail": "project.components.dht",
        "documentation": {}
    },
    {
        "label": "dht_batch",
        "kind": 5,
        "importPath": "project.components.dht",
        "description": "project.components.dht",
        "peekOfCode": "dht_batch = []\npublish_data_counter = 0\npublish_data_limit = 5\ncounter_lock = threading.Lock()\ndef publisher_task(event, dht_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_dht_batch = dht_batch.copy()",
        "detail": "project.components.dht",
        "documentation": {}
    },
    {
        "label": "publish_data_counter",
        "kind": 5,
        "importPath": "project.components.dht",
        "description": "project.components.dht",
        "peekOfCode": "publish_data_counter = 0\npublish_data_limit = 5\ncounter_lock = threading.Lock()\ndef publisher_task(event, dht_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_dht_batch = dht_batch.copy()\n            publish_data_counter = 0",
        "detail": "project.components.dht",
        "documentation": {}
    },
    {
        "label": "publish_data_limit",
        "kind": 5,
        "importPath": "project.components.dht",
        "description": "project.components.dht",
        "peekOfCode": "publish_data_limit = 5\ncounter_lock = threading.Lock()\ndef publisher_task(event, dht_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_dht_batch = dht_batch.copy()\n            publish_data_counter = 0\n            dht_batch.clear()",
        "detail": "project.components.dht",
        "documentation": {}
    },
    {
        "label": "counter_lock",
        "kind": 5,
        "importPath": "project.components.dht",
        "description": "project.components.dht",
        "peekOfCode": "counter_lock = threading.Lock()\ndef publisher_task(event, dht_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_dht_batch = dht_batch.copy()\n            publish_data_counter = 0\n            dht_batch.clear()\n        publish.multiple(local_dht_batch, hostname=HOSTNAME, port=PORT)",
        "detail": "project.components.dht",
        "documentation": {}
    },
    {
        "label": "publish_event",
        "kind": 5,
        "importPath": "project.components.dht",
        "description": "project.components.dht",
        "peekOfCode": "publish_event = threading.Event()\npublisher_thread = threading.Thread(target=publisher_task, args=(publish_event, dht_batch,))\npublisher_thread.daemon = True\npublisher_thread.start()\ndef dht_callback(humidity, temperature, publish_event, dht_settings, code=\"DHTLIB_OK\", verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + dht_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")",
        "detail": "project.components.dht",
        "documentation": {}
    },
    {
        "label": "publisher_thread",
        "kind": 5,
        "importPath": "project.components.dht",
        "description": "project.components.dht",
        "peekOfCode": "publisher_thread = threading.Thread(target=publisher_task, args=(publish_event, dht_batch,))\npublisher_thread.daemon = True\npublisher_thread.start()\ndef dht_callback(humidity, temperature, publish_event, dht_settings, code=\"DHTLIB_OK\", verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + dht_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")\n        print(f\"Code: {code}\")",
        "detail": "project.components.dht",
        "documentation": {}
    },
    {
        "label": "publisher_thread.daemon",
        "kind": 5,
        "importPath": "project.components.dht",
        "description": "project.components.dht",
        "peekOfCode": "publisher_thread.daemon = True\npublisher_thread.start()\ndef dht_callback(humidity, temperature, publish_event, dht_settings, code=\"DHTLIB_OK\", verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + dht_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")\n        print(f\"Code: {code}\")\n        print(f\"Humidity: {humidity}%\")",
        "detail": "project.components.dht",
        "documentation": {}
    },
    {
        "label": "publisher_task",
        "kind": 2,
        "importPath": "project.components.dioda",
        "description": "project.components.dioda",
        "peekOfCode": "def publisher_task(event, light_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_dht_batch = light_batch.copy()\n            publish_data_counter = 0\n            light_batch.clear()\n        publish.multiple(local_dht_batch, hostname=HOSTNAME, port=PORT)\n        print(f'Published {publish_data_limit} light values')",
        "detail": "project.components.dioda",
        "documentation": {}
    },
    {
        "label": "light_callback",
        "kind": 2,
        "importPath": "project.components.dioda",
        "description": "project.components.dioda",
        "peekOfCode": "def light_callback(state, publish_event, dht_settings, verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + dht_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")\n        print(f\"Light on: {state}\")\n    payload = {\n        \"measurement\": \"Light_state\",\n        \"simulated\": dht_settings['simulated'],",
        "detail": "project.components.dioda",
        "documentation": {}
    },
    {
        "label": "run_dioda",
        "kind": 2,
        "importPath": "project.components.dioda",
        "description": "project.components.dioda",
        "peekOfCode": "def run_dioda(pipe, settings, threads, stop_event):\n    if settings['simulated']:\n        print(\"Starting {} simulator\".format(settings[\"name\"]))\n        uds_thread = threading.Thread(target=run_dioda_simulator,\n                                      args=(pipe, 0.5, light_callback, stop_event, publish_event, settings))\n        uds_thread.start()\n        threads.append(uds_thread)\n        print(\"{0} simulator started\".format(settings[\"name\"]))\n    else:\n        from sensors.dioda import run_dioda_loop, Dioda",
        "detail": "project.components.dioda",
        "documentation": {}
    },
    {
        "label": "light_batch",
        "kind": 5,
        "importPath": "project.components.dioda",
        "description": "project.components.dioda",
        "peekOfCode": "light_batch = []\npublish_data_counter = 0\npublish_data_limit = 3\ncounter_lock = threading.Lock()\ndef publisher_task(event, light_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_dht_batch = light_batch.copy()",
        "detail": "project.components.dioda",
        "documentation": {}
    },
    {
        "label": "publish_data_counter",
        "kind": 5,
        "importPath": "project.components.dioda",
        "description": "project.components.dioda",
        "peekOfCode": "publish_data_counter = 0\npublish_data_limit = 3\ncounter_lock = threading.Lock()\ndef publisher_task(event, light_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_dht_batch = light_batch.copy()\n            publish_data_counter = 0",
        "detail": "project.components.dioda",
        "documentation": {}
    },
    {
        "label": "publish_data_limit",
        "kind": 5,
        "importPath": "project.components.dioda",
        "description": "project.components.dioda",
        "peekOfCode": "publish_data_limit = 3\ncounter_lock = threading.Lock()\ndef publisher_task(event, light_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_dht_batch = light_batch.copy()\n            publish_data_counter = 0\n            light_batch.clear()",
        "detail": "project.components.dioda",
        "documentation": {}
    },
    {
        "label": "counter_lock",
        "kind": 5,
        "importPath": "project.components.dioda",
        "description": "project.components.dioda",
        "peekOfCode": "counter_lock = threading.Lock()\ndef publisher_task(event, light_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_dht_batch = light_batch.copy()\n            publish_data_counter = 0\n            light_batch.clear()\n        publish.multiple(local_dht_batch, hostname=HOSTNAME, port=PORT)",
        "detail": "project.components.dioda",
        "documentation": {}
    },
    {
        "label": "publish_event",
        "kind": 5,
        "importPath": "project.components.dioda",
        "description": "project.components.dioda",
        "peekOfCode": "publish_event = threading.Event()\npublisher_thread = threading.Thread(target=publisher_task, args=(publish_event, light_batch,))\npublisher_thread.daemon = True\npublisher_thread.start()\ndef light_callback(state, publish_event, dht_settings, verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + dht_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")",
        "detail": "project.components.dioda",
        "documentation": {}
    },
    {
        "label": "publisher_thread",
        "kind": 5,
        "importPath": "project.components.dioda",
        "description": "project.components.dioda",
        "peekOfCode": "publisher_thread = threading.Thread(target=publisher_task, args=(publish_event, light_batch,))\npublisher_thread.daemon = True\npublisher_thread.start()\ndef light_callback(state, publish_event, dht_settings, verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + dht_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")\n        print(f\"Light on: {state}\")",
        "detail": "project.components.dioda",
        "documentation": {}
    },
    {
        "label": "publisher_thread.daemon",
        "kind": 5,
        "importPath": "project.components.dioda",
        "description": "project.components.dioda",
        "peekOfCode": "publisher_thread.daemon = True\npublisher_thread.start()\ndef light_callback(state, publish_event, dht_settings, verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + dht_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")\n        print(f\"Light on: {state}\")\n    payload = {",
        "detail": "project.components.dioda",
        "documentation": {}
    },
    {
        "label": "publisher_task",
        "kind": 2,
        "importPath": "project.components.gyro",
        "description": "project.components.gyro",
        "peekOfCode": "def publisher_task(event, gyro_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_gyro_batch = gyro_batch.copy()\n            publish_data_counter = 0\n            gyro_batch.clear()\n        publish.multiple(local_gyro_batch, hostname=HOSTNAME, port=PORT)\n        print(f'Published {publish_data_limit} gyro values')",
        "detail": "project.components.gyro",
        "documentation": {}
    },
    {
        "label": "gyro_callback",
        "kind": 2,
        "importPath": "project.components.gyro",
        "description": "project.components.gyro",
        "peekOfCode": "def gyro_callback(accel, gyro, publish_event, gyro_settings, verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + gyro_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")\n        print(f\"Acceleration: {accel}%\")\n        print(f\"Gyroscope: {gyro}C\")\n    accel_payloads = []\n    gyro_payloads = []",
        "detail": "project.components.gyro",
        "documentation": {}
    },
    {
        "label": "run_gyro",
        "kind": 2,
        "importPath": "project.components.gyro",
        "description": "project.components.gyro",
        "peekOfCode": "def run_gyro(settings, threads, stop_event):\n    if settings['simulated']:\n        print(\"Starting {} simulator\".format(settings[\"name\"]))\n        gyro_thread = threading.Thread(target=run_gyro_simulator, args=(2, gyro_callback, stop_event, publish_event, settings))\n        gyro_thread.start()\n        threads.append(gyro_thread)\n        print(\"{0} simulator started\".format(settings[\"name\"]))\n    else:\n        from sensors.Gyro.gyro import run_gyro_loop, MPU6050\n        print(\"Starting {} loop\".format(settings[\"name\"]))",
        "detail": "project.components.gyro",
        "documentation": {}
    },
    {
        "label": "gyro_batch",
        "kind": 5,
        "importPath": "project.components.gyro",
        "description": "project.components.gyro",
        "peekOfCode": "gyro_batch = []\npublish_data_counter = 0\npublish_data_limit = 6\ncounter_lock = threading.Lock()\ndef publisher_task(event, gyro_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_gyro_batch = gyro_batch.copy()",
        "detail": "project.components.gyro",
        "documentation": {}
    },
    {
        "label": "publish_data_counter",
        "kind": 5,
        "importPath": "project.components.gyro",
        "description": "project.components.gyro",
        "peekOfCode": "publish_data_counter = 0\npublish_data_limit = 6\ncounter_lock = threading.Lock()\ndef publisher_task(event, gyro_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_gyro_batch = gyro_batch.copy()\n            publish_data_counter = 0",
        "detail": "project.components.gyro",
        "documentation": {}
    },
    {
        "label": "publish_data_limit",
        "kind": 5,
        "importPath": "project.components.gyro",
        "description": "project.components.gyro",
        "peekOfCode": "publish_data_limit = 6\ncounter_lock = threading.Lock()\ndef publisher_task(event, gyro_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_gyro_batch = gyro_batch.copy()\n            publish_data_counter = 0\n            gyro_batch.clear()",
        "detail": "project.components.gyro",
        "documentation": {}
    },
    {
        "label": "counter_lock",
        "kind": 5,
        "importPath": "project.components.gyro",
        "description": "project.components.gyro",
        "peekOfCode": "counter_lock = threading.Lock()\ndef publisher_task(event, gyro_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_gyro_batch = gyro_batch.copy()\n            publish_data_counter = 0\n            gyro_batch.clear()\n        publish.multiple(local_gyro_batch, hostname=HOSTNAME, port=PORT)",
        "detail": "project.components.gyro",
        "documentation": {}
    },
    {
        "label": "publish_event",
        "kind": 5,
        "importPath": "project.components.gyro",
        "description": "project.components.gyro",
        "peekOfCode": "publish_event = threading.Event()\npublisher_thread = threading.Thread(target=publisher_task, args=(publish_event, gyro_batch,))\npublisher_thread.daemon = True\npublisher_thread.start()\ndef gyro_callback(accel, gyro, publish_event, gyro_settings, verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + gyro_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")",
        "detail": "project.components.gyro",
        "documentation": {}
    },
    {
        "label": "publisher_thread",
        "kind": 5,
        "importPath": "project.components.gyro",
        "description": "project.components.gyro",
        "peekOfCode": "publisher_thread = threading.Thread(target=publisher_task, args=(publish_event, gyro_batch,))\npublisher_thread.daemon = True\npublisher_thread.start()\ndef gyro_callback(accel, gyro, publish_event, gyro_settings, verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + gyro_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")\n        print(f\"Acceleration: {accel}%\")",
        "detail": "project.components.gyro",
        "documentation": {}
    },
    {
        "label": "publisher_thread.daemon",
        "kind": 5,
        "importPath": "project.components.gyro",
        "description": "project.components.gyro",
        "peekOfCode": "publisher_thread.daemon = True\npublisher_thread.start()\ndef gyro_callback(accel, gyro, publish_event, gyro_settings, verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + gyro_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")\n        print(f\"Acceleration: {accel}%\")\n        print(f\"Gyroscope: {gyro}C\")",
        "detail": "project.components.gyro",
        "documentation": {}
    },
    {
        "label": "lcd_callback",
        "kind": 2,
        "importPath": "project.components.lcd",
        "description": "project.components.lcd",
        "peekOfCode": "def lcd_callback(humidity, temperature, lcd_settings):\n        t = time.localtime()\n        print(\"=\" * 10 + lcd_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")\n        print(\"Showing data below\")\n        print(f\"Humidity: {humidity}%\")\n        print(f\"Temperature: {temperature}C\")\ndef run_lcd(settings, threads, stop_event,hostname,port):\n    if settings['simulated']:\n        print(\"Starting {} simulator\".format(settings[\"name\"]))",
        "detail": "project.components.lcd",
        "documentation": {}
    },
    {
        "label": "run_lcd",
        "kind": 2,
        "importPath": "project.components.lcd",
        "description": "project.components.lcd",
        "peekOfCode": "def run_lcd(settings, threads, stop_event,hostname,port):\n    if settings['simulated']:\n        print(\"Starting {} simulator\".format(settings[\"name\"]))\n        lcd_thread = threading.Thread(target=run_lcd_simulator, args=(2, lcd_callback, stop_event, settings,hostname,port))\n        lcd_thread.start()\n        threads.append(lcd_thread)\n        print(\"{0} simulator started\".format(settings[\"name\"]))\n    else:\n        from sensors.LCD.lcd import run_lcd_loop, create_lcd_and_adapter\n        print(\"Starting {} loop\".format(settings[\"name\"]))",
        "detail": "project.components.lcd",
        "documentation": {}
    },
    {
        "label": "publisher_task",
        "kind": 2,
        "importPath": "project.components.ms",
        "description": "project.components.ms",
        "peekOfCode": "def publisher_task(event, ms_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_dht_batch = ms_batch.copy()\n            publish_data_counter = 0\n            ms_batch.clear()\n        publish.multiple(local_dht_batch, hostname=HOSTNAME, port=PORT)\n        print(f'Published {publish_data_limit} ms values')",
        "detail": "project.components.ms",
        "documentation": {}
    },
    {
        "label": "ms_callback",
        "kind": 2,
        "importPath": "project.components.ms",
        "description": "project.components.ms",
        "peekOfCode": "def ms_callback(code, publish_event, dht_settings, verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + dht_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")\n        print(f\"Code: {code}\")\n    payload = {\n        \"measurement\": \"MS_password\",\n        \"simulated\": dht_settings['simulated'],",
        "detail": "project.components.ms",
        "documentation": {}
    },
    {
        "label": "run_ms",
        "kind": 2,
        "importPath": "project.components.ms",
        "description": "project.components.ms",
        "peekOfCode": "def run_ms(settings, threads, stop_event):\n    if settings['simulated']:\n        print(\"Starting {} simulator\".format(settings[\"name\"]))\n        ms_thread = threading.Thread(target=run_ms_simulator, args=(2, ms_callback, stop_event, publish_event, settings))\n        ms_thread.start()\n        threads.append(ms_thread)\n        print(\"{0} simulator started\".format(settings[\"name\"]))\n    else:\n        from sensors.ms import run_ms_loop, MS\n        print(\"Starting {} loop\".format(settings[\"name\"]))",
        "detail": "project.components.ms",
        "documentation": {}
    },
    {
        "label": "ms_batch",
        "kind": 5,
        "importPath": "project.components.ms",
        "description": "project.components.ms",
        "peekOfCode": "ms_batch = []\npublish_data_counter = 0\npublish_data_limit = 4\ncounter_lock = threading.Lock()\ndef publisher_task(event, ms_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_dht_batch = ms_batch.copy()",
        "detail": "project.components.ms",
        "documentation": {}
    },
    {
        "label": "publish_data_counter",
        "kind": 5,
        "importPath": "project.components.ms",
        "description": "project.components.ms",
        "peekOfCode": "publish_data_counter = 0\npublish_data_limit = 4\ncounter_lock = threading.Lock()\ndef publisher_task(event, ms_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_dht_batch = ms_batch.copy()\n            publish_data_counter = 0",
        "detail": "project.components.ms",
        "documentation": {}
    },
    {
        "label": "publish_data_limit",
        "kind": 5,
        "importPath": "project.components.ms",
        "description": "project.components.ms",
        "peekOfCode": "publish_data_limit = 4\ncounter_lock = threading.Lock()\ndef publisher_task(event, ms_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_dht_batch = ms_batch.copy()\n            publish_data_counter = 0\n            ms_batch.clear()",
        "detail": "project.components.ms",
        "documentation": {}
    },
    {
        "label": "counter_lock",
        "kind": 5,
        "importPath": "project.components.ms",
        "description": "project.components.ms",
        "peekOfCode": "counter_lock = threading.Lock()\ndef publisher_task(event, ms_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_dht_batch = ms_batch.copy()\n            publish_data_counter = 0\n            ms_batch.clear()\n        publish.multiple(local_dht_batch, hostname=HOSTNAME, port=PORT)",
        "detail": "project.components.ms",
        "documentation": {}
    },
    {
        "label": "publish_event",
        "kind": 5,
        "importPath": "project.components.ms",
        "description": "project.components.ms",
        "peekOfCode": "publish_event = threading.Event()\npublisher_thread = threading.Thread(target=publisher_task, args=(publish_event, ms_batch,))\npublisher_thread.daemon = True\npublisher_thread.start()\ndef ms_callback(code, publish_event, dht_settings, verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + dht_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")",
        "detail": "project.components.ms",
        "documentation": {}
    },
    {
        "label": "publisher_thread",
        "kind": 5,
        "importPath": "project.components.ms",
        "description": "project.components.ms",
        "peekOfCode": "publisher_thread = threading.Thread(target=publisher_task, args=(publish_event, ms_batch,))\npublisher_thread.daemon = True\npublisher_thread.start()\ndef ms_callback(code, publish_event, dht_settings, verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + dht_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")\n        print(f\"Code: {code}\")",
        "detail": "project.components.ms",
        "documentation": {}
    },
    {
        "label": "publisher_thread.daemon",
        "kind": 5,
        "importPath": "project.components.ms",
        "description": "project.components.ms",
        "peekOfCode": "publisher_thread.daemon = True\npublisher_thread.start()\ndef ms_callback(code, publish_event, dht_settings, verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + dht_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")\n        print(f\"Code: {code}\")\n    payload = {",
        "detail": "project.components.ms",
        "documentation": {}
    },
    {
        "label": "publisher_task",
        "kind": 2,
        "importPath": "project.components.pir",
        "description": "project.components.pir",
        "peekOfCode": "def publisher_task(event, pir_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_dht_batch = pir_batch.copy()\n            publish_data_counter = 0\n            pir_batch.clear()\n        publish.multiple(local_dht_batch, hostname=HOSTNAME, port=PORT)\n        print(f'Published {publish_data_limit} pir values')",
        "detail": "project.components.pir",
        "documentation": {}
    },
    {
        "label": "motion_callback",
        "kind": 2,
        "importPath": "project.components.pir",
        "description": "project.components.pir",
        "peekOfCode": "def motion_callback(publish_event, dht_settings, value, verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + dht_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")\n        print(\"Detected motion\")\n    payload = {\n        \"measurement\": \"PIR_motion\",\n        \"simulated\": dht_settings['simulated'],",
        "detail": "project.components.pir",
        "documentation": {}
    },
    {
        "label": "run_pir",
        "kind": 2,
        "importPath": "project.components.pir",
        "description": "project.components.pir",
        "peekOfCode": "def run_pir(settings, threads, stop_event):\n    if settings['simulated']:\n        print(\"Starting {} simulator\".format(settings[\"name\"]))\n        pir_thread = threading.Thread(target=run_pir_simulator, args=(2, motion_callback, stop_event, publish_event, settings))\n        pir_thread.start()\n        threads.append(pir_thread)\n        print(\"{0} simulator started\".format(settings[\"name\"]))\n    else:\n        from sensors.pir import run_pir_loop, PIR\n        print(\"Starting {} loop\".format(settings[\"name\"]))",
        "detail": "project.components.pir",
        "documentation": {}
    },
    {
        "label": "pir_batch",
        "kind": 5,
        "importPath": "project.components.pir",
        "description": "project.components.pir",
        "peekOfCode": "pir_batch = []\npublish_data_counter = 0\npublish_data_limit = 4\ncounter_lock = threading.Lock()\ndef publisher_task(event, pir_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_dht_batch = pir_batch.copy()",
        "detail": "project.components.pir",
        "documentation": {}
    },
    {
        "label": "publish_data_counter",
        "kind": 5,
        "importPath": "project.components.pir",
        "description": "project.components.pir",
        "peekOfCode": "publish_data_counter = 0\npublish_data_limit = 4\ncounter_lock = threading.Lock()\ndef publisher_task(event, pir_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_dht_batch = pir_batch.copy()\n            publish_data_counter = 0",
        "detail": "project.components.pir",
        "documentation": {}
    },
    {
        "label": "publish_data_limit",
        "kind": 5,
        "importPath": "project.components.pir",
        "description": "project.components.pir",
        "peekOfCode": "publish_data_limit = 4\ncounter_lock = threading.Lock()\ndef publisher_task(event, pir_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_dht_batch = pir_batch.copy()\n            publish_data_counter = 0\n            pir_batch.clear()",
        "detail": "project.components.pir",
        "documentation": {}
    },
    {
        "label": "counter_lock",
        "kind": 5,
        "importPath": "project.components.pir",
        "description": "project.components.pir",
        "peekOfCode": "counter_lock = threading.Lock()\ndef publisher_task(event, pir_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_dht_batch = pir_batch.copy()\n            publish_data_counter = 0\n            pir_batch.clear()\n        publish.multiple(local_dht_batch, hostname=HOSTNAME, port=PORT)",
        "detail": "project.components.pir",
        "documentation": {}
    },
    {
        "label": "publish_event",
        "kind": 5,
        "importPath": "project.components.pir",
        "description": "project.components.pir",
        "peekOfCode": "publish_event = threading.Event()\npublisher_thread = threading.Thread(target=publisher_task, args=(publish_event, pir_batch,))\npublisher_thread.daemon = True\npublisher_thread.start()\ndef motion_callback(publish_event, dht_settings, value, verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + dht_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")",
        "detail": "project.components.pir",
        "documentation": {}
    },
    {
        "label": "publisher_thread",
        "kind": 5,
        "importPath": "project.components.pir",
        "description": "project.components.pir",
        "peekOfCode": "publisher_thread = threading.Thread(target=publisher_task, args=(publish_event, pir_batch,))\npublisher_thread.daemon = True\npublisher_thread.start()\ndef motion_callback(publish_event, dht_settings, value, verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + dht_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")\n        print(\"Detected motion\")",
        "detail": "project.components.pir",
        "documentation": {}
    },
    {
        "label": "publisher_thread.daemon",
        "kind": 5,
        "importPath": "project.components.pir",
        "description": "project.components.pir",
        "peekOfCode": "publisher_thread.daemon = True\npublisher_thread.start()\ndef motion_callback(publish_event, dht_settings, value, verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + dht_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")\n        print(\"Detected motion\")\n    payload = {",
        "detail": "project.components.pir",
        "documentation": {}
    },
    {
        "label": "publisher_task",
        "kind": 2,
        "importPath": "project.components.rgb",
        "description": "project.components.rgb",
        "peekOfCode": "def publisher_task(event, rgb_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_rgb_batch = rgb_batch.copy()\n            publish_data_counter = 0\n            rgb_batch.clear()\n        publish.multiple(local_rgb_batch, hostname=HOSTNAME, port=PORT)\n        print(f'Published {publish_data_limit} rgb values')",
        "detail": "project.components.rgb",
        "documentation": {}
    },
    {
        "label": "rgb_callback",
        "kind": 2,
        "importPath": "project.components.rgb",
        "description": "project.components.rgb",
        "peekOfCode": "def rgb_callback(status, publish_event, rgb_settings, verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + rgb_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")\n        print(f\"Status changed: {status}%\")\n    payload = {\n        \"measurement\": \"RGB\",\n        \"simulated\": rgb_settings['simulated'],",
        "detail": "project.components.rgb",
        "documentation": {}
    },
    {
        "label": "run_rgb",
        "kind": 2,
        "importPath": "project.components.rgb",
        "description": "project.components.rgb",
        "peekOfCode": "def run_rgb(settings, threads, stop_event,hostname,port):\n    if settings['simulated']:\n        print(\"Starting {} simulator\".format(settings[\"name\"]))\n        rgb_thread = threading.Thread(target=run_rgb_simulator, args=(2, rgb_callback, stop_event, publish_event, settings,hostname,port))\n        rgb_thread.start()\n        threads.append(rgb_thread)\n        print(\"{0} simulator started\".format(settings[\"name\"]))\n    else:\n        from sensors.rgb import run_rgb_loop, RGB\n        print(\"Starting {} loop\".format(settings[\"name\"]))",
        "detail": "project.components.rgb",
        "documentation": {}
    },
    {
        "label": "rgb_batch",
        "kind": 5,
        "importPath": "project.components.rgb",
        "description": "project.components.rgb",
        "peekOfCode": "rgb_batch = []\npublish_data_counter = 0\npublish_data_limit = 1\ncounter_lock = threading.Lock()\ndef publisher_task(event, rgb_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_rgb_batch = rgb_batch.copy()",
        "detail": "project.components.rgb",
        "documentation": {}
    },
    {
        "label": "publish_data_counter",
        "kind": 5,
        "importPath": "project.components.rgb",
        "description": "project.components.rgb",
        "peekOfCode": "publish_data_counter = 0\npublish_data_limit = 1\ncounter_lock = threading.Lock()\ndef publisher_task(event, rgb_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_rgb_batch = rgb_batch.copy()\n            publish_data_counter = 0",
        "detail": "project.components.rgb",
        "documentation": {}
    },
    {
        "label": "publish_data_limit",
        "kind": 5,
        "importPath": "project.components.rgb",
        "description": "project.components.rgb",
        "peekOfCode": "publish_data_limit = 1\ncounter_lock = threading.Lock()\ndef publisher_task(event, rgb_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_rgb_batch = rgb_batch.copy()\n            publish_data_counter = 0\n            rgb_batch.clear()",
        "detail": "project.components.rgb",
        "documentation": {}
    },
    {
        "label": "counter_lock",
        "kind": 5,
        "importPath": "project.components.rgb",
        "description": "project.components.rgb",
        "peekOfCode": "counter_lock = threading.Lock()\ndef publisher_task(event, rgb_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_rgb_batch = rgb_batch.copy()\n            publish_data_counter = 0\n            rgb_batch.clear()\n        publish.multiple(local_rgb_batch, hostname=HOSTNAME, port=PORT)",
        "detail": "project.components.rgb",
        "documentation": {}
    },
    {
        "label": "publish_event",
        "kind": 5,
        "importPath": "project.components.rgb",
        "description": "project.components.rgb",
        "peekOfCode": "publish_event = threading.Event()\npublisher_thread = threading.Thread(target=publisher_task, args=(publish_event, rgb_batch,))\npublisher_thread.daemon = True\npublisher_thread.start()\ndef rgb_callback(status, publish_event, rgb_settings, verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + rgb_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")",
        "detail": "project.components.rgb",
        "documentation": {}
    },
    {
        "label": "publisher_thread",
        "kind": 5,
        "importPath": "project.components.rgb",
        "description": "project.components.rgb",
        "peekOfCode": "publisher_thread = threading.Thread(target=publisher_task, args=(publish_event, rgb_batch,))\npublisher_thread.daemon = True\npublisher_thread.start()\ndef rgb_callback(status, publish_event, rgb_settings, verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + rgb_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")\n        print(f\"Status changed: {status}%\")",
        "detail": "project.components.rgb",
        "documentation": {}
    },
    {
        "label": "publisher_thread.daemon",
        "kind": 5,
        "importPath": "project.components.rgb",
        "description": "project.components.rgb",
        "peekOfCode": "publisher_thread.daemon = True\npublisher_thread.start()\ndef rgb_callback(status, publish_event, rgb_settings, verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + rgb_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")\n        print(f\"Status changed: {status}%\")\n    payload = {",
        "detail": "project.components.rgb",
        "documentation": {}
    },
    {
        "label": "publisher_task",
        "kind": 2,
        "importPath": "project.components.uds",
        "description": "project.components.uds",
        "peekOfCode": "def publisher_task(event, uds_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_dht_batch = uds_batch.copy()\n            publish_data_counter = 0\n            uds_batch.clear()\n        publish.multiple(local_dht_batch, hostname=HOSTNAME, port=PORT)\n        print(f'Published {publish_data_limit} uds values')",
        "detail": "project.components.uds",
        "documentation": {}
    },
    {
        "label": "uds_callback",
        "kind": 2,
        "importPath": "project.components.uds",
        "description": "project.components.uds",
        "peekOfCode": "def uds_callback(distance, publish_event, dht_settings, verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + dht_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")\n        print(f\"Distance: {distance}cm\")\n    payload = {\n        \"measurement\": \"UDS\",\n        \"simulated\": dht_settings['simulated'],",
        "detail": "project.components.uds",
        "documentation": {}
    },
    {
        "label": "run_uds",
        "kind": 2,
        "importPath": "project.components.uds",
        "description": "project.components.uds",
        "peekOfCode": "def run_uds(settings, threads, stop_event):\n    if settings['simulated']:\n        print(\"Starting {} simulator\".format(settings[\"name\"]))\n        uds_thread = threading.Thread(target=run_uds_simulator,\n                                      args=(2, uds_callback, stop_event, publish_event, settings))\n        uds_thread.start()\n        threads.append(uds_thread)\n        print(\"{0} simulator started\".format(settings[\"name\"]))\n    else:\n        from sensors.uds import run_uds_loop, UDS",
        "detail": "project.components.uds",
        "documentation": {}
    },
    {
        "label": "uds_batch",
        "kind": 5,
        "importPath": "project.components.uds",
        "description": "project.components.uds",
        "peekOfCode": "uds_batch = []\npublish_data_counter = 0\npublish_data_limit = 5\ncounter_lock = threading.Lock()\ndef publisher_task(event, uds_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_dht_batch = uds_batch.copy()",
        "detail": "project.components.uds",
        "documentation": {}
    },
    {
        "label": "publish_data_counter",
        "kind": 5,
        "importPath": "project.components.uds",
        "description": "project.components.uds",
        "peekOfCode": "publish_data_counter = 0\npublish_data_limit = 5\ncounter_lock = threading.Lock()\ndef publisher_task(event, uds_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_dht_batch = uds_batch.copy()\n            publish_data_counter = 0",
        "detail": "project.components.uds",
        "documentation": {}
    },
    {
        "label": "publish_data_limit",
        "kind": 5,
        "importPath": "project.components.uds",
        "description": "project.components.uds",
        "peekOfCode": "publish_data_limit = 5\ncounter_lock = threading.Lock()\ndef publisher_task(event, uds_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_dht_batch = uds_batch.copy()\n            publish_data_counter = 0\n            uds_batch.clear()",
        "detail": "project.components.uds",
        "documentation": {}
    },
    {
        "label": "counter_lock",
        "kind": 5,
        "importPath": "project.components.uds",
        "description": "project.components.uds",
        "peekOfCode": "counter_lock = threading.Lock()\ndef publisher_task(event, uds_batch):\n    global publish_data_counter, publish_data_limit\n    while True:\n        event.wait()\n        with counter_lock:\n            local_dht_batch = uds_batch.copy()\n            publish_data_counter = 0\n            uds_batch.clear()\n        publish.multiple(local_dht_batch, hostname=HOSTNAME, port=PORT)",
        "detail": "project.components.uds",
        "documentation": {}
    },
    {
        "label": "publish_event",
        "kind": 5,
        "importPath": "project.components.uds",
        "description": "project.components.uds",
        "peekOfCode": "publish_event = threading.Event()\npublisher_thread = threading.Thread(target=publisher_task, args=(publish_event, uds_batch,))\npublisher_thread.daemon = True\npublisher_thread.start()\ndef uds_callback(distance, publish_event, dht_settings, verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + dht_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")",
        "detail": "project.components.uds",
        "documentation": {}
    },
    {
        "label": "publisher_thread",
        "kind": 5,
        "importPath": "project.components.uds",
        "description": "project.components.uds",
        "peekOfCode": "publisher_thread = threading.Thread(target=publisher_task, args=(publish_event, uds_batch,))\npublisher_thread.daemon = True\npublisher_thread.start()\ndef uds_callback(distance, publish_event, dht_settings, verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + dht_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")\n        print(f\"Distance: {distance}cm\")",
        "detail": "project.components.uds",
        "documentation": {}
    },
    {
        "label": "publisher_thread.daemon",
        "kind": 5,
        "importPath": "project.components.uds",
        "description": "project.components.uds",
        "peekOfCode": "publisher_thread.daemon = True\npublisher_thread.start()\ndef uds_callback(distance, publish_event, dht_settings, verbose=False):\n    global publish_data_counter, publish_data_limit\n    if verbose:\n        t = time.localtime()\n        print(\"=\" * 10 + dht_settings[\"name\"] + \"=\" * 10)\n        print(f\"Timestamp: {time.strftime('%H:%M:%S', t)}\")\n        print(f\"Distance: {distance}cm\")\n    payload = {",
        "detail": "project.components.uds",
        "documentation": {}
    },
    {
        "label": "MPU6050",
        "kind": 6,
        "importPath": "project.sensors.Gyro.MPU6050",
        "description": "project.sensors.Gyro.MPU6050",
        "peekOfCode": "class MPU6050:\n    __buffer = [0] * 14\n    __debug = False\n    __DMP_packet_size = 0\n    __dev_id = 0\n    __bus = None\n    def __init__(self, a_bus=1, a_address=C.MPU6050_DEFAULT_ADDRESS,\n                 a_xAOff=None, a_yAOff=None, a_zAOff=None, a_xGOff=None,\n                 a_yGOff=None, a_zGOff=None, a_debug=False):\n        self.__dev_id = a_address",
        "detail": "project.sensors.Gyro.MPU6050",
        "documentation": {}
    },
    {
        "label": "MPU6050IRQHandler",
        "kind": 6,
        "importPath": "project.sensors.Gyro.MPU6050",
        "description": "project.sensors.Gyro.MPU6050",
        "peekOfCode": "class MPU6050IRQHandler:\n    __mpu = MPU6050\n    __FIFO_buffer = list()\n    __count = 0\n    __packet_size = None\n    __detected_error = False\n    __logging = False\n    __log_file = None\n    __csv_writer = None\n    __start_time = None",
        "detail": "project.sensors.Gyro.MPU6050",
        "documentation": {}
    },
    {
        "label": "__author__",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050",
        "description": "project.sensors.Gyro.MPU6050",
        "peekOfCode": "__author__ = 'Geir Istad'\n\"\"\"\nMPU6050 Python I2C Class\nCopyright (c) 2015 Geir Istad\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:",
        "detail": "project.sensors.Gyro.MPU6050",
        "documentation": {}
    },
    {
        "label": "avg_from_array",
        "kind": 2,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "def avg_from_array(a_array):\n    sum = 0.0\n    for index in range(0, len(a_array)):\n        sum += a_array[index]\n    return sum/len(a_array)\ni2c_bus = 1\ndevice_address = 0x68\n# The offsets are different for each device and should be changed\n# accordingly using a calibration procedure\nx_accel_offset = 0",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "i2c_bus",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "i2c_bus = 1\ndevice_address = 0x68\n# The offsets are different for each device and should be changed\n# accordingly using a calibration procedure\nx_accel_offset = 0\ny_accel_offset = 0\nz_accel_offset =0\nx_gyro_offset = 0\ny_gyro_offset = 0\nz_gyro_offset = 0",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "device_address",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "device_address = 0x68\n# The offsets are different for each device and should be changed\n# accordingly using a calibration procedure\nx_accel_offset = 0\ny_accel_offset = 0\nz_accel_offset =0\nx_gyro_offset = 0\ny_gyro_offset = 0\nz_gyro_offset = 0\nenable_debug_output = True",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "x_accel_offset",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "x_accel_offset = 0\ny_accel_offset = 0\nz_accel_offset =0\nx_gyro_offset = 0\ny_gyro_offset = 0\nz_gyro_offset = 0\nenable_debug_output = True\nmpu = MPU6050(i2c_bus, device_address, x_accel_offset, y_accel_offset,\n              z_accel_offset, x_gyro_offset, y_gyro_offset, z_gyro_offset,\n              enable_debug_output)",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "y_accel_offset",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "y_accel_offset = 0\nz_accel_offset =0\nx_gyro_offset = 0\ny_gyro_offset = 0\nz_gyro_offset = 0\nenable_debug_output = True\nmpu = MPU6050(i2c_bus, device_address, x_accel_offset, y_accel_offset,\n              z_accel_offset, x_gyro_offset, y_gyro_offset, z_gyro_offset,\n              enable_debug_output)\nkp = 0.03125",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "x_gyro_offset",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "x_gyro_offset = 0\ny_gyro_offset = 0\nz_gyro_offset = 0\nenable_debug_output = True\nmpu = MPU6050(i2c_bus, device_address, x_accel_offset, y_accel_offset,\n              z_accel_offset, x_gyro_offset, y_gyro_offset, z_gyro_offset,\n              enable_debug_output)\nkp = 0.03125\nki = 0.25\nkd = 0",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "y_gyro_offset",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "y_gyro_offset = 0\nz_gyro_offset = 0\nenable_debug_output = True\nmpu = MPU6050(i2c_bus, device_address, x_accel_offset, y_accel_offset,\n              z_accel_offset, x_gyro_offset, y_gyro_offset, z_gyro_offset,\n              enable_debug_output)\nkp = 0.03125\nki = 0.25\nkd = 0\npidax = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "z_gyro_offset",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "z_gyro_offset = 0\nenable_debug_output = True\nmpu = MPU6050(i2c_bus, device_address, x_accel_offset, y_accel_offset,\n              z_accel_offset, x_gyro_offset, y_gyro_offset, z_gyro_offset,\n              enable_debug_output)\nkp = 0.03125\nki = 0.25\nkd = 0\npidax = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\npiday = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "enable_debug_output",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "enable_debug_output = True\nmpu = MPU6050(i2c_bus, device_address, x_accel_offset, y_accel_offset,\n              z_accel_offset, x_gyro_offset, y_gyro_offset, z_gyro_offset,\n              enable_debug_output)\nkp = 0.03125\nki = 0.25\nkd = 0\npidax = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\npiday = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\npidaz = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "mpu",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "mpu = MPU6050(i2c_bus, device_address, x_accel_offset, y_accel_offset,\n              z_accel_offset, x_gyro_offset, y_gyro_offset, z_gyro_offset,\n              enable_debug_output)\nkp = 0.03125\nki = 0.25\nkd = 0\npidax = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\npiday = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\npidaz = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\npidgx = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "kp",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "kp = 0.03125\nki = 0.25\nkd = 0\npidax = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\npiday = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\npidaz = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\npidgx = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\npidgy = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\npidgz = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\naccel_reading = mpu.get_acceleration()",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "ki",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "ki = 0.25\nkd = 0\npidax = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\npiday = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\npidaz = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\npidgx = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\npidgy = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\npidgz = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\naccel_reading = mpu.get_acceleration()\nx_accel_reading = accel_reading[0]",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "kd",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "kd = 0\npidax = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\npiday = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\npidaz = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\npidgx = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\npidgy = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\npidgz = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\naccel_reading = mpu.get_acceleration()\nx_accel_reading = accel_reading[0]\ny_accel_reading = accel_reading[1]",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "pidax",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "pidax = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\npiday = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\npidaz = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\npidgx = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\npidgy = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\npidgz = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\naccel_reading = mpu.get_acceleration()\nx_accel_reading = accel_reading[0]\ny_accel_reading = accel_reading[1]\nz_accel_reading = accel_reading[2]",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "piday",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "piday = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\npidaz = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\npidgx = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\npidgy = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\npidgz = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\naccel_reading = mpu.get_acceleration()\nx_accel_reading = accel_reading[0]\ny_accel_reading = accel_reading[1]\nz_accel_reading = accel_reading[2]\nx_accel_avg = [0]*100",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "pidaz",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "pidaz = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\npidgx = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\npidgy = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\npidgz = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\naccel_reading = mpu.get_acceleration()\nx_accel_reading = accel_reading[0]\ny_accel_reading = accel_reading[1]\nz_accel_reading = accel_reading[2]\nx_accel_avg = [0]*100\ny_accel_avg = [0]*100",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "pidgx",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "pidgx = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\npidgy = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\npidgz = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\naccel_reading = mpu.get_acceleration()\nx_accel_reading = accel_reading[0]\ny_accel_reading = accel_reading[1]\nz_accel_reading = accel_reading[2]\nx_accel_avg = [0]*100\ny_accel_avg = [0]*100\nz_accel_avg = [0]*100",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "pidgy",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "pidgy = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\npidgz = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\naccel_reading = mpu.get_acceleration()\nx_accel_reading = accel_reading[0]\ny_accel_reading = accel_reading[1]\nz_accel_reading = accel_reading[2]\nx_accel_avg = [0]*100\ny_accel_avg = [0]*100\nz_accel_avg = [0]*100\nx_accel_offset_avg = [0]*100",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "pidgz",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "pidgz = SimplePID(0, -15000, 15000, kp, ki, kd, 100, True)\naccel_reading = mpu.get_acceleration()\nx_accel_reading = accel_reading[0]\ny_accel_reading = accel_reading[1]\nz_accel_reading = accel_reading[2]\nx_accel_avg = [0]*100\ny_accel_avg = [0]*100\nz_accel_avg = [0]*100\nx_accel_offset_avg = [0]*100\ny_accel_offset_avg = [0]*100",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "accel_reading",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "accel_reading = mpu.get_acceleration()\nx_accel_reading = accel_reading[0]\ny_accel_reading = accel_reading[1]\nz_accel_reading = accel_reading[2]\nx_accel_avg = [0]*100\ny_accel_avg = [0]*100\nz_accel_avg = [0]*100\nx_accel_offset_avg = [0]*100\ny_accel_offset_avg = [0]*100\nz_accel_offset_avg = [0]*100",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "x_accel_reading",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "x_accel_reading = accel_reading[0]\ny_accel_reading = accel_reading[1]\nz_accel_reading = accel_reading[2]\nx_accel_avg = [0]*100\ny_accel_avg = [0]*100\nz_accel_avg = [0]*100\nx_accel_offset_avg = [0]*100\ny_accel_offset_avg = [0]*100\nz_accel_offset_avg = [0]*100\naxindex = 0",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "y_accel_reading",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "y_accel_reading = accel_reading[1]\nz_accel_reading = accel_reading[2]\nx_accel_avg = [0]*100\ny_accel_avg = [0]*100\nz_accel_avg = [0]*100\nx_accel_offset_avg = [0]*100\ny_accel_offset_avg = [0]*100\nz_accel_offset_avg = [0]*100\naxindex = 0\nayindex = 0",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "z_accel_reading",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "z_accel_reading = accel_reading[2]\nx_accel_avg = [0]*100\ny_accel_avg = [0]*100\nz_accel_avg = [0]*100\nx_accel_offset_avg = [0]*100\ny_accel_offset_avg = [0]*100\nz_accel_offset_avg = [0]*100\naxindex = 0\nayindex = 0\nazindex = 0",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "x_accel_avg",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "x_accel_avg = [0]*100\ny_accel_avg = [0]*100\nz_accel_avg = [0]*100\nx_accel_offset_avg = [0]*100\ny_accel_offset_avg = [0]*100\nz_accel_offset_avg = [0]*100\naxindex = 0\nayindex = 0\nazindex = 0\ngyro_reading = mpu.get_rotation()",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "y_accel_avg",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "y_accel_avg = [0]*100\nz_accel_avg = [0]*100\nx_accel_offset_avg = [0]*100\ny_accel_offset_avg = [0]*100\nz_accel_offset_avg = [0]*100\naxindex = 0\nayindex = 0\nazindex = 0\ngyro_reading = mpu.get_rotation()\nx_gyro_reading = gyro_reading[0]",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "z_accel_avg",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "z_accel_avg = [0]*100\nx_accel_offset_avg = [0]*100\ny_accel_offset_avg = [0]*100\nz_accel_offset_avg = [0]*100\naxindex = 0\nayindex = 0\nazindex = 0\ngyro_reading = mpu.get_rotation()\nx_gyro_reading = gyro_reading[0]\ny_gyro_reading = gyro_reading[1]",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "x_accel_offset_avg",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "x_accel_offset_avg = [0]*100\ny_accel_offset_avg = [0]*100\nz_accel_offset_avg = [0]*100\naxindex = 0\nayindex = 0\nazindex = 0\ngyro_reading = mpu.get_rotation()\nx_gyro_reading = gyro_reading[0]\ny_gyro_reading = gyro_reading[1]\nz_gyro_reading = gyro_reading[2]",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "y_accel_offset_avg",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "y_accel_offset_avg = [0]*100\nz_accel_offset_avg = [0]*100\naxindex = 0\nayindex = 0\nazindex = 0\ngyro_reading = mpu.get_rotation()\nx_gyro_reading = gyro_reading[0]\ny_gyro_reading = gyro_reading[1]\nz_gyro_reading = gyro_reading[2]\nx_gyro_avg = [0]*100",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "z_accel_offset_avg",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "z_accel_offset_avg = [0]*100\naxindex = 0\nayindex = 0\nazindex = 0\ngyro_reading = mpu.get_rotation()\nx_gyro_reading = gyro_reading[0]\ny_gyro_reading = gyro_reading[1]\nz_gyro_reading = gyro_reading[2]\nx_gyro_avg = [0]*100\ny_gyro_avg = [0]*100",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "axindex",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "axindex = 0\nayindex = 0\nazindex = 0\ngyro_reading = mpu.get_rotation()\nx_gyro_reading = gyro_reading[0]\ny_gyro_reading = gyro_reading[1]\nz_gyro_reading = gyro_reading[2]\nx_gyro_avg = [0]*100\ny_gyro_avg = [0]*100\nz_gyro_avg = [0]*100",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "ayindex",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "ayindex = 0\nazindex = 0\ngyro_reading = mpu.get_rotation()\nx_gyro_reading = gyro_reading[0]\ny_gyro_reading = gyro_reading[1]\nz_gyro_reading = gyro_reading[2]\nx_gyro_avg = [0]*100\ny_gyro_avg = [0]*100\nz_gyro_avg = [0]*100\nx_gyro_offset_avg = [0]*100",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "azindex",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "azindex = 0\ngyro_reading = mpu.get_rotation()\nx_gyro_reading = gyro_reading[0]\ny_gyro_reading = gyro_reading[1]\nz_gyro_reading = gyro_reading[2]\nx_gyro_avg = [0]*100\ny_gyro_avg = [0]*100\nz_gyro_avg = [0]*100\nx_gyro_offset_avg = [0]*100\ny_gyro_offset_avg = [0]*100",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "gyro_reading",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "gyro_reading = mpu.get_rotation()\nx_gyro_reading = gyro_reading[0]\ny_gyro_reading = gyro_reading[1]\nz_gyro_reading = gyro_reading[2]\nx_gyro_avg = [0]*100\ny_gyro_avg = [0]*100\nz_gyro_avg = [0]*100\nx_gyro_offset_avg = [0]*100\ny_gyro_offset_avg = [0]*100\nz_gyro_offset_avg = [0]*100",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "x_gyro_reading",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "x_gyro_reading = gyro_reading[0]\ny_gyro_reading = gyro_reading[1]\nz_gyro_reading = gyro_reading[2]\nx_gyro_avg = [0]*100\ny_gyro_avg = [0]*100\nz_gyro_avg = [0]*100\nx_gyro_offset_avg = [0]*100\ny_gyro_offset_avg = [0]*100\nz_gyro_offset_avg = [0]*100\ngxindex = 0",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "y_gyro_reading",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "y_gyro_reading = gyro_reading[1]\nz_gyro_reading = gyro_reading[2]\nx_gyro_avg = [0]*100\ny_gyro_avg = [0]*100\nz_gyro_avg = [0]*100\nx_gyro_offset_avg = [0]*100\ny_gyro_offset_avg = [0]*100\nz_gyro_offset_avg = [0]*100\ngxindex = 0\ngyindex = 0",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "z_gyro_reading",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "z_gyro_reading = gyro_reading[2]\nx_gyro_avg = [0]*100\ny_gyro_avg = [0]*100\nz_gyro_avg = [0]*100\nx_gyro_offset_avg = [0]*100\ny_gyro_offset_avg = [0]*100\nz_gyro_offset_avg = [0]*100\ngxindex = 0\ngyindex = 0\ngzindex = 0",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "x_gyro_avg",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "x_gyro_avg = [0]*100\ny_gyro_avg = [0]*100\nz_gyro_avg = [0]*100\nx_gyro_offset_avg = [0]*100\ny_gyro_offset_avg = [0]*100\nz_gyro_offset_avg = [0]*100\ngxindex = 0\ngyindex = 0\ngzindex = 0\ntry:",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "y_gyro_avg",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "y_gyro_avg = [0]*100\nz_gyro_avg = [0]*100\nx_gyro_offset_avg = [0]*100\ny_gyro_offset_avg = [0]*100\nz_gyro_offset_avg = [0]*100\ngxindex = 0\ngyindex = 0\ngzindex = 0\ntry:\n    while True:",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "z_gyro_avg",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "z_gyro_avg = [0]*100\nx_gyro_offset_avg = [0]*100\ny_gyro_offset_avg = [0]*100\nz_gyro_offset_avg = [0]*100\ngxindex = 0\ngyindex = 0\ngzindex = 0\ntry:\n    while True:\n        accel_reading = mpu.get_acceleration()",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "x_gyro_offset_avg",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "x_gyro_offset_avg = [0]*100\ny_gyro_offset_avg = [0]*100\nz_gyro_offset_avg = [0]*100\ngxindex = 0\ngyindex = 0\ngzindex = 0\ntry:\n    while True:\n        accel_reading = mpu.get_acceleration()\n        x_accel_reading = accel_reading[0]",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "y_gyro_offset_avg",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "y_gyro_offset_avg = [0]*100\nz_gyro_offset_avg = [0]*100\ngxindex = 0\ngyindex = 0\ngzindex = 0\ntry:\n    while True:\n        accel_reading = mpu.get_acceleration()\n        x_accel_reading = accel_reading[0]\n        y_accel_reading = accel_reading[1]",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "z_gyro_offset_avg",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "z_gyro_offset_avg = [0]*100\ngxindex = 0\ngyindex = 0\ngzindex = 0\ntry:\n    while True:\n        accel_reading = mpu.get_acceleration()\n        x_accel_reading = accel_reading[0]\n        y_accel_reading = accel_reading[1]\n        z_accel_reading = accel_reading[2]",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "gxindex",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "gxindex = 0\ngyindex = 0\ngzindex = 0\ntry:\n    while True:\n        accel_reading = mpu.get_acceleration()\n        x_accel_reading = accel_reading[0]\n        y_accel_reading = accel_reading[1]\n        z_accel_reading = accel_reading[2]\n        gyro_reading = mpu.get_rotation()",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "gyindex",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "gyindex = 0\ngzindex = 0\ntry:\n    while True:\n        accel_reading = mpu.get_acceleration()\n        x_accel_reading = accel_reading[0]\n        y_accel_reading = accel_reading[1]\n        z_accel_reading = accel_reading[2]\n        gyro_reading = mpu.get_rotation()\n        x_gyro_reading = gyro_reading[0]",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "gzindex",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPU6050_cal",
        "description": "project.sensors.Gyro.MPU6050_cal",
        "peekOfCode": "gzindex = 0\ntry:\n    while True:\n        accel_reading = mpu.get_acceleration()\n        x_accel_reading = accel_reading[0]\n        y_accel_reading = accel_reading[1]\n        z_accel_reading = accel_reading[2]\n        gyro_reading = mpu.get_rotation()\n        x_gyro_reading = gyro_reading[0]\n        y_gyro_reading = gyro_reading[1]",
        "detail": "project.sensors.Gyro.MPU6050_cal",
        "documentation": {}
    },
    {
        "label": "MPUConstants",
        "kind": 6,
        "importPath": "project.sensors.Gyro.MPUConstants",
        "description": "project.sensors.Gyro.MPUConstants",
        "peekOfCode": "class MPUConstants:\n    # From MPU6050.h\n    MPU6050_ADDRESS_AD0_LOW = 0x68  # address pin low (GND), default\n    MPU6050_ADDRESS_AD0_HIGH = 0x69  # address pin high (VCC)\n    MPU6050_DEFAULT_ADDRESS = MPU6050_ADDRESS_AD0_LOW\n    # [7] PWR_MODE, [6:1] XG_OFFS_TC, [0] OTP_BNK_VLD\n    MPU6050_RA_XG_OFFS_TC = 0x00\n    # [7] PWR_MODE, [6:1] YG_OFFS_TC, [0] OTP_BNK_VLD\n    MPU6050_RA_YG_OFFS_TC = 0x01\n    # [7] PWR_MODE, [6:1] ZG_OFFS_TC, [0] OTP_BNK_VLD",
        "detail": "project.sensors.Gyro.MPUConstants",
        "documentation": {}
    },
    {
        "label": "__author__",
        "kind": 5,
        "importPath": "project.sensors.Gyro.MPUConstants",
        "description": "project.sensors.Gyro.MPUConstants",
        "peekOfCode": "__author__ = 'Geir Istad'\n'''\nMPU6050 Python I2C Class\nCopyright (c) 2015 Geir Istad\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:",
        "detail": "project.sensors.Gyro.MPUConstants",
        "documentation": {}
    },
    {
        "label": "Quaternion",
        "kind": 6,
        "importPath": "project.sensors.Gyro.Quaternion",
        "description": "project.sensors.Gyro.Quaternion",
        "peekOfCode": "class Quaternion:\n    w = 0.0\n    x = 0.0\n    y = 0.0\n    z = 0.0\n    def __init__(self, a_w=1.0, a_x=0.0, a_y=0.0, a_z=0.0):\n        self.w = a_w\n        self.x = a_x\n        self.y = a_y\n        self.z = a_z",
        "detail": "project.sensors.Gyro.Quaternion",
        "documentation": {}
    },
    {
        "label": "XYZVector",
        "kind": 6,
        "importPath": "project.sensors.Gyro.Quaternion",
        "description": "project.sensors.Gyro.Quaternion",
        "peekOfCode": "class XYZVector:\n    x = 0.0\n    y = 0.0\n    z = 0.0\n    def __init__(self, a_x=0.0, a_y=0.0, a_z=0.0):\n        self.x = a_x\n        self.y = a_y\n        self.z = a_z\n    def get_magnitude(self):\n        return sqrt(self.x*self.x + self.y*self.y + self.z*self.z)",
        "detail": "project.sensors.Gyro.Quaternion",
        "documentation": {}
    },
    {
        "label": "__author__",
        "kind": 5,
        "importPath": "project.sensors.Gyro.Quaternion",
        "description": "project.sensors.Gyro.Quaternion",
        "peekOfCode": "__author__ = 'Geir Istad'\n\"\"\"\nMPU6050 Python I2C Class\nCopyright (c) 2015 Geir Istad\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:",
        "detail": "project.sensors.Gyro.Quaternion",
        "documentation": {}
    },
    {
        "label": "run_gyro_loop",
        "kind": 2,
        "importPath": "project.sensors.Gyro.gyro",
        "description": "project.sensors.Gyro.gyro",
        "peekOfCode": "def run_gyro_loop(mpu, delay, callback, stop_event, publish_event, settings):\n    mpu.dmp_initialize()\n    while True:\n        accel = mpu.get_acceleration()     \n        gyro = mpu.get_rotation()          \n        accel = [a/16384.0 for a in accel]\n        gyro = [g/131.0 for g in gyro]\n        callback(accel, gyro, publish_event, settings)\n        os.system('clear')\n        if stop_event.is_set():",
        "detail": "project.sensors.Gyro.gyro",
        "documentation": {}
    },
    {
        "label": "accel",
        "kind": 5,
        "importPath": "project.sensors.Gyro.gyro",
        "description": "project.sensors.Gyro.gyro",
        "peekOfCode": "accel = [0]*3               \ngyro = [0]*3                \ndef run_gyro_loop(mpu, delay, callback, stop_event, publish_event, settings):\n    mpu.dmp_initialize()\n    while True:\n        accel = mpu.get_acceleration()     \n        gyro = mpu.get_rotation()          \n        accel = [a/16384.0 for a in accel]\n        gyro = [g/131.0 for g in gyro]\n        callback(accel, gyro, publish_event, settings)",
        "detail": "project.sensors.Gyro.gyro",
        "documentation": {}
    },
    {
        "label": "gyro",
        "kind": 5,
        "importPath": "project.sensors.Gyro.gyro",
        "description": "project.sensors.Gyro.gyro",
        "peekOfCode": "gyro = [0]*3                \ndef run_gyro_loop(mpu, delay, callback, stop_event, publish_event, settings):\n    mpu.dmp_initialize()\n    while True:\n        accel = mpu.get_acceleration()     \n        gyro = mpu.get_rotation()          \n        accel = [a/16384.0 for a in accel]\n        gyro = [g/131.0 for g in gyro]\n        callback(accel, gyro, publish_event, settings)\n        os.system('clear')",
        "detail": "project.sensors.Gyro.gyro",
        "documentation": {}
    },
    {
        "label": "Adafruit_CharLCD",
        "kind": 6,
        "importPath": "project.sensors.LCD.Adafruit_LCD1602",
        "description": "project.sensors.LCD.Adafruit_LCD1602",
        "peekOfCode": "class Adafruit_CharLCD(object):\n    # commands\n    LCD_CLEARDISPLAY        = 0x01\n    LCD_RETURNHOME          = 0x02\n    LCD_ENTRYMODESET        = 0x04\n    LCD_DISPLAYCONTROL      = 0x08\n    LCD_CURSORSHIFT         = 0x10\n    LCD_FUNCTIONSET         = 0x20\n    LCD_SETCGRAMADDR        = 0x40\n    LCD_SETDDRAMADDR        = 0x80",
        "detail": "project.sensors.LCD.Adafruit_LCD1602",
        "documentation": {}
    },
    {
        "label": "PCF8574_I2C",
        "kind": 6,
        "importPath": "project.sensors.LCD.PCF8574",
        "description": "project.sensors.LCD.PCF8574",
        "peekOfCode": "class PCF8574_I2C(object):\n    OUPUT = 0\n    INPUT = 1\n    def __init__(self, address):\n        # Note you need to change the bus number to 0 if running on a revision 1 Raspberry Pi.\n        self.bus = smbus.SMBus(1)\n        self.address = address\n        self.currentValue = 0\n        self.writeByte(0)  # I2C test.\n    def readByte(self):  # Read PCF8574 all port of the data",
        "detail": "project.sensors.LCD.PCF8574",
        "documentation": {}
    },
    {
        "label": "PCF8574_GPIO",
        "kind": 6,
        "importPath": "project.sensors.LCD.PCF8574",
        "description": "project.sensors.LCD.PCF8574",
        "peekOfCode": "class PCF8574_GPIO(object):  # Standardization function interface\n    OUT = 0\n    IN = 1\n    BCM = 0\n    BOARD = 0\n    def __init__(self, address):\n        self.chip = PCF8574_I2C(address)\n        self.address = address\n    def setmode(self, mode):  # PCF8574 port belongs to two-way IO, do not need to set the input and output model\n        pass",
        "detail": "project.sensors.LCD.PCF8574",
        "documentation": {}
    },
    {
        "label": "on_connect",
        "kind": 2,
        "importPath": "project.sensors.LCD.lcd",
        "description": "project.sensors.LCD.lcd",
        "peekOfCode": "def on_connect(client, userdata, flags, rc):\n    client.subscribe(\"data/temperature\")\n    client.subscribe(\"data/humidity\")\ndef update_data(topic, data):\n    global humidity, temperature\n    if data[\"name\"] == DHT_NAME:\n        if topic == \"data/temperature\":\n            temperature = data[\"value\"]\n        elif topic == \"data/humidity\":\n            humidity = data[\"value\"]",
        "detail": "project.sensors.LCD.lcd",
        "documentation": {}
    },
    {
        "label": "update_data",
        "kind": 2,
        "importPath": "project.sensors.LCD.lcd",
        "description": "project.sensors.LCD.lcd",
        "peekOfCode": "def update_data(topic, data):\n    global humidity, temperature\n    if data[\"name\"] == DHT_NAME:\n        if topic == \"data/temperature\":\n            temperature = data[\"value\"]\n        elif topic == \"data/humidity\":\n            humidity = data[\"value\"]\ndef connect_mqtt(hostname,port):\n    # MQTT Configuration\n    mqtt_client = mqtt.Client()",
        "detail": "project.sensors.LCD.lcd",
        "documentation": {}
    },
    {
        "label": "connect_mqtt",
        "kind": 2,
        "importPath": "project.sensors.LCD.lcd",
        "description": "project.sensors.LCD.lcd",
        "peekOfCode": "def connect_mqtt(hostname,port):\n    # MQTT Configuration\n    mqtt_client = mqtt.Client()\n    mqtt_client.connect(hostname,port, 60)\n    mqtt_client.loop_start()\n    mqtt_client.on_connect = on_connect\n    mqtt_client.on_message = lambda client, userdata, msg: update_data(msg.topic, json.loads(msg.payload.decode('utf-8')))\ndef create_lcd_and_adapter(settings):\n    PCF8574_address = 0x27  # I2C address of the PCF8574 chip.\n    PCF8574A_address = 0x3F  # I2C address of the PCF8574A chip.",
        "detail": "project.sensors.LCD.lcd",
        "documentation": {}
    },
    {
        "label": "create_lcd_and_adapter",
        "kind": 2,
        "importPath": "project.sensors.LCD.lcd",
        "description": "project.sensors.LCD.lcd",
        "peekOfCode": "def create_lcd_and_adapter(settings):\n    PCF8574_address = 0x27  # I2C address of the PCF8574 chip.\n    PCF8574A_address = 0x3F  # I2C address of the PCF8574A chip.\n    # Create PCF8574 GPIO adapter.\n    try:\n        mcp = PCF8574_GPIO(PCF8574_address)\n    except:\n        try:\n            mcp = PCF8574_GPIO(PCF8574A_address)\n        except:",
        "detail": "project.sensors.LCD.lcd",
        "documentation": {}
    },
    {
        "label": "run_lcd_loop",
        "kind": 2,
        "importPath": "project.sensors.LCD.lcd",
        "description": "project.sensors.LCD.lcd",
        "peekOfCode": "def run_lcd_loop(lcd, mcp, delay, callback, stop_event, settings,hostname,port):\n    mcp.output(3, 1)     # turn on LCD backlight\n    lcd.begin(16, 2)     # set number of LCD lines and columns\n    connect_mqtt(hostname,port)\n    while True:\n        lcd.clear()\n        lcd.setCursor(0, 0)  # set cursor position\n        lcd.message(\"Humidity: \", humidity)\n        lcd.message(\"Temperature: \", temperature)\n        callback(humidity, temperature, settings)",
        "detail": "project.sensors.LCD.lcd",
        "documentation": {}
    },
    {
        "label": "humidity",
        "kind": 5,
        "importPath": "project.sensors.LCD.lcd",
        "description": "project.sensors.LCD.lcd",
        "peekOfCode": "humidity = 0\ntemperature = 0\nDHT_NAME = \"GDHT\"\ndef on_connect(client, userdata, flags, rc):\n    client.subscribe(\"data/temperature\")\n    client.subscribe(\"data/humidity\")\ndef update_data(topic, data):\n    global humidity, temperature\n    if data[\"name\"] == DHT_NAME:\n        if topic == \"data/temperature\":",
        "detail": "project.sensors.LCD.lcd",
        "documentation": {}
    },
    {
        "label": "temperature",
        "kind": 5,
        "importPath": "project.sensors.LCD.lcd",
        "description": "project.sensors.LCD.lcd",
        "peekOfCode": "temperature = 0\nDHT_NAME = \"GDHT\"\ndef on_connect(client, userdata, flags, rc):\n    client.subscribe(\"data/temperature\")\n    client.subscribe(\"data/humidity\")\ndef update_data(topic, data):\n    global humidity, temperature\n    if data[\"name\"] == DHT_NAME:\n        if topic == \"data/temperature\":\n            temperature = data[\"value\"]",
        "detail": "project.sensors.LCD.lcd",
        "documentation": {}
    },
    {
        "label": "DHT_NAME",
        "kind": 5,
        "importPath": "project.sensors.LCD.lcd",
        "description": "project.sensors.LCD.lcd",
        "peekOfCode": "DHT_NAME = \"GDHT\"\ndef on_connect(client, userdata, flags, rc):\n    client.subscribe(\"data/temperature\")\n    client.subscribe(\"data/humidity\")\ndef update_data(topic, data):\n    global humidity, temperature\n    if data[\"name\"] == DHT_NAME:\n        if topic == \"data/temperature\":\n            temperature = data[\"value\"]\n        elif topic == \"data/humidity\":",
        "detail": "project.sensors.LCD.lcd",
        "documentation": {}
    },
    {
        "label": "IR",
        "kind": 6,
        "importPath": "project.sensors.IR",
        "description": "project.sensors.IR",
        "peekOfCode": "class IR:\n    def __init__(self, pin, name):\n        self.pin = int(pin)\n        self.name = name\n        GPIO.setup(pin, GPIO.IN)\n        self.buttons = [0x300ff22dd, 0x300ffc23d, 0x300ff629d, 0x300ffa857, 0x300ff9867, 0x300ffb04f, 0x300ff6897,\n                   0x300ff02fd,\n                   0x300ff30cf, 0x300ff18e7, 0x300ff7a85, 0x300ff10ef, 0x300ff38c7, 0x300ff5aa5, 0x300ff42bd,\n                   0x300ff4ab5,\n                   0x300ff52ad]  # HEX code list",
        "detail": "project.sensors.IR",
        "documentation": {}
    },
    {
        "label": "run_ir_loop",
        "kind": 2,
        "importPath": "project.sensors.IR",
        "description": "project.sensors.IR",
        "peekOfCode": "def run_ir_loop(ir, delay, callback, stop_event, publish_event, settings):\n    while True:\n        inData = ir.convertHex(ir.getBinary())  # Runs subs to get incoming hex value\n        for button in range(len(ir.buttons)):  # Runs through every value in list\n            if hex(ir.buttons[button]) == inData:  # Checks this against incoming\n                callback(ir.buttons_names[button], publish_event, settings)  # Prints corresponding english name for button\n        if stop_event.is_set():\n            break",
        "detail": "project.sensors.IR",
        "documentation": {}
    },
    {
        "label": "Button",
        "kind": 6,
        "importPath": "project.sensors.button",
        "description": "project.sensors.button",
        "peekOfCode": "class Button:\n    def __init__(self, pin, name):\n        self.pin = int(pin)\n        self.name = name\n        GPIO.setup(self.pin, GPIO.OUT)\ndef run_button_loop(button, button_pressed, button_released, stop_event, publish_event, settings):\n    GPIO.setup(button.pin, GPIO.IN, pull_up_down=GPIO.PUD_UP)\n    GPIO.add_event_detect(button.pin, GPIO.RISING, callback=lambda channel: button_pressed(publish_event, settings),\n                          bouncetime=100)\n    while True:",
        "detail": "project.sensors.button",
        "documentation": {}
    },
    {
        "label": "run_button_loop",
        "kind": 2,
        "importPath": "project.sensors.button",
        "description": "project.sensors.button",
        "peekOfCode": "def run_button_loop(button, button_pressed, button_released, stop_event, publish_event, settings):\n    GPIO.setup(button.pin, GPIO.IN, pull_up_down=GPIO.PUD_UP)\n    GPIO.add_event_detect(button.pin, GPIO.RISING, callback=lambda channel: button_pressed(publish_event, settings),\n                          bouncetime=100)\n    while True:\n        if stop_event.is_set():\n            GPIO.remove_event_detect(button.pin)\n            break",
        "detail": "project.sensors.button",
        "documentation": {}
    },
    {
        "label": "DHT",
        "kind": 6,
        "importPath": "project.sensors.dht",
        "description": "project.sensors.dht",
        "peekOfCode": "class DHT:\n    DHTLIB_OK = 0\n    DHTLIB_ERROR_CHECKSUM = -1\n    DHTLIB_ERROR_TIMEOUT = -2\n    DHTLIB_INVALID_VALUE = -999\n    DHTLIB_DHT11_WAKEUP = 0.020  # 0.018\t\t#18ms\n    DHTLIB_TIMEOUT = 0.0001  # 100us\n    humidity = 0\n    temperature = 0\n    def __init__(self, name, pin):",
        "detail": "project.sensors.dht",
        "documentation": {}
    },
    {
        "label": "parseCheckCode",
        "kind": 2,
        "importPath": "project.sensors.dht",
        "description": "project.sensors.dht",
        "peekOfCode": "def parseCheckCode(code):\n    if code == 0:\n        return \"DHTLIB_OK\"\n    elif code == -1:\n        return \"DHTLIB_ERROR_CHECKSUM\"\n    elif code == -2:\n        return \"DHTLIB_ERROR_TIMEOUT\"\n    elif code == -999:\n        return \"DHTLIB_INVALID_VALUE\"\ndef run_dht_loop(dht, delay, callback, stop_event, publish_event, settings):",
        "detail": "project.sensors.dht",
        "documentation": {}
    },
    {
        "label": "run_dht_loop",
        "kind": 2,
        "importPath": "project.sensors.dht",
        "description": "project.sensors.dht",
        "peekOfCode": "def run_dht_loop(dht, delay, callback, stop_event, publish_event, settings):\n    while True:\n        check = dht.readDHT11()\n        code = parseCheckCode(check)\n        humidity, temperature = dht.humidity, dht.temperature\n        callback(humidity, temperature, publish_event, settings, code)\n        if stop_event.is_set():\n            break\n        time.sleep(delay)  # Delay between readings",
        "detail": "project.sensors.dht",
        "documentation": {}
    },
    {
        "label": "MS",
        "kind": 6,
        "importPath": "project.sensors.ms",
        "description": "project.sensors.ms",
        "peekOfCode": "class MS:\n    def __init__(self, settings):\n        self.R1 = int(settings[\"R1\"])\n        self.R2 = int(settings[\"R2\"])\n        self.R3 = int(settings[\"R3\"])\n        self.R4 = int(settings[\"R4\"])\n        self.C1 = int(settings[\"C1\"])\n        self.C2 = int(settings[\"C2\"])\n        self.C3 = int(settings[\"C3\"])\n        self.C4 = int(settings[\"C4\"])",
        "detail": "project.sensors.ms",
        "documentation": {}
    },
    {
        "label": "run_ms_loop",
        "kind": 2,
        "importPath": "project.sensors.ms",
        "description": "project.sensors.ms",
        "peekOfCode": "def run_ms_loop(ms, delay, callback, stop_event, publish_event, settings):\n    while True:\n        passcode = ms.get_pass()\n        callback(passcode, publish_event, settings)\n        if stop_event.is_set():\n            break\n        time.sleep(delay)  # Delay between readings",
        "detail": "project.sensors.ms",
        "documentation": {}
    },
    {
        "label": "PIR",
        "kind": 6,
        "importPath": "project.sensors.pir",
        "description": "project.sensors.pir",
        "peekOfCode": "class PIR:\n    def __init__(self, pin, name):\n        self.pin = int(pin)\n        self.name = name\n        GPIO.setup(pin, GPIO.IN)\ndef motion_callback(channel, motion_detected, publish_event, settings):\n    motion_detected(publish_event, settings, 1)\ndef run_pir_loop(pir, motion_detected, stop_event, publish_event, settings):\n    def callback_wrapper(channel):\n        motion_callback(channel, motion_detected, publish_event, settings)",
        "detail": "project.sensors.pir",
        "documentation": {}
    },
    {
        "label": "motion_callback",
        "kind": 2,
        "importPath": "project.sensors.pir",
        "description": "project.sensors.pir",
        "peekOfCode": "def motion_callback(channel, motion_detected, publish_event, settings):\n    motion_detected(publish_event, settings, 1)\ndef run_pir_loop(pir, motion_detected, stop_event, publish_event, settings):\n    def callback_wrapper(channel):\n        motion_callback(channel, motion_detected, publish_event, settings)\n    GPIO.add_event_detect(pir.pin, GPIO.RISING, callback=callback_wrapper)\n    while True:\n        if stop_event.is_set():\n            GPIO.remove_event_detect(pir.pin)\n            break",
        "detail": "project.sensors.pir",
        "documentation": {}
    },
    {
        "label": "run_pir_loop",
        "kind": 2,
        "importPath": "project.sensors.pir",
        "description": "project.sensors.pir",
        "peekOfCode": "def run_pir_loop(pir, motion_detected, stop_event, publish_event, settings):\n    def callback_wrapper(channel):\n        motion_callback(channel, motion_detected, publish_event, settings)\n    GPIO.add_event_detect(pir.pin, GPIO.RISING, callback=callback_wrapper)\n    while True:\n        if stop_event.is_set():\n            GPIO.remove_event_detect(pir.pin)\n            break",
        "detail": "project.sensors.pir",
        "documentation": {}
    },
    {
        "label": "UDS",
        "kind": 6,
        "importPath": "project.sensors.uds",
        "description": "project.sensors.uds",
        "peekOfCode": "class UDS:\n    def __init__(self, trig_pin, echo_pin, name):\n        self.trig_pin = trig_pin\n        self.echo_pin = echo_pin\n        GPIO.setup(self.trig_pin, GPIO.OUT)\n        GPIO.setup(self.echo_pin, GPIO.IN)\n        self.max_iter = 100\n        self.name = name\n    def get_distance(self):\n        GPIO.output(self.trig_pin, False)",
        "detail": "project.sensors.uds",
        "documentation": {}
    },
    {
        "label": "run_uds_loop",
        "kind": 2,
        "importPath": "project.sensors.uds",
        "description": "project.sensors.uds",
        "peekOfCode": "def run_uds_loop(uds, delay, callback, stop_event, publish_event, settings):\n    try:\n        while True:\n            distance = get_distance(trigger_pin, echo_pin)\n            if distance is not None:\n                callback(distance, publish_event, settings)\n            else:\n                print('Measurement timed out')\n            time.sleep(delay)\n    except KeyboardInterrupt:",
        "detail": "project.sensors.uds",
        "documentation": {}
    },
    {
        "label": "load_settings",
        "kind": 2,
        "importPath": "project.settings.settings",
        "description": "project.settings.settings",
        "peekOfCode": "def load_settings():\n    file_path = \"settings/settings.json\"\n    with open(file_path, 'r') as f:\n        return json.load(f)\nlock = threading.Lock()",
        "detail": "project.settings.settings",
        "documentation": {}
    },
    {
        "label": "HOSTNAME",
        "kind": 5,
        "importPath": "project.settings.settings",
        "description": "project.settings.settings",
        "peekOfCode": "HOSTNAME = \"192.168.1.100\"\nPORT = 1883\nlock = threading.Lock()\ndef load_settings():\n    file_path = \"settings/settings.json\"\n    with open(file_path, 'r') as f:\n        return json.load(f)\nlock = threading.Lock()",
        "detail": "project.settings.settings",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": "project.settings.settings",
        "description": "project.settings.settings",
        "peekOfCode": "PORT = 1883\nlock = threading.Lock()\ndef load_settings():\n    file_path = \"settings/settings.json\"\n    with open(file_path, 'r') as f:\n        return json.load(f)\nlock = threading.Lock()",
        "detail": "project.settings.settings",
        "documentation": {}
    },
    {
        "label": "lock",
        "kind": 5,
        "importPath": "project.settings.settings",
        "description": "project.settings.settings",
        "peekOfCode": "lock = threading.Lock()\ndef load_settings():\n    file_path = \"settings/settings.json\"\n    with open(file_path, 'r') as f:\n        return json.load(f)\nlock = threading.Lock()",
        "detail": "project.settings.settings",
        "documentation": {}
    },
    {
        "label": "lock",
        "kind": 5,
        "importPath": "project.settings.settings",
        "description": "project.settings.settings",
        "peekOfCode": "lock = threading.Lock()",
        "detail": "project.settings.settings",
        "documentation": {}
    },
    {
        "label": "get_key",
        "kind": 2,
        "importPath": "project.simulations.IR",
        "description": "project.simulations.IR",
        "peekOfCode": "def get_key():\n        index = random.randint(0, len(buttons_names) - 1)\n        return buttons_names[index]\ndef run_ir_simulator(delay, callback, stop_event, publish_event, settings):\n    while True:\n        key = get_key()\n        callback(key, publish_event, settings)\n        if stop_event.is_set():\n            break\n        time.sleep(delay)",
        "detail": "project.simulations.IR",
        "documentation": {}
    },
    {
        "label": "run_ir_simulator",
        "kind": 2,
        "importPath": "project.simulations.IR",
        "description": "project.simulations.IR",
        "peekOfCode": "def run_ir_simulator(delay, callback, stop_event, publish_event, settings):\n    while True:\n        key = get_key()\n        callback(key, publish_event, settings)\n        if stop_event.is_set():\n            break\n        time.sleep(delay)",
        "detail": "project.simulations.IR",
        "documentation": {}
    },
    {
        "label": "buttons_names",
        "kind": 5,
        "importPath": "project.simulations.IR",
        "description": "project.simulations.IR",
        "peekOfCode": "buttons_names = [\"LEFT\", \"RIGHT\", \"UP\", \"DOWN\", \"2\", \"3\", \"1\", \"OK\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"*\", \"0\", \"#\"]\n# String list in same order as HEX list\ndef get_key():\n        index = random.randint(0, len(buttons_names) - 1)\n        return buttons_names[index]\ndef run_ir_simulator(delay, callback, stop_event, publish_event, settings):\n    while True:\n        key = get_key()\n        callback(key, publish_event, settings)\n        if stop_event.is_set():",
        "detail": "project.simulations.IR",
        "documentation": {}
    },
    {
        "label": "generate_value",
        "kind": 2,
        "importPath": "project.simulations.b4sd",
        "description": "project.simulations.b4sd",
        "peekOfCode": "def generate_value():\n    n = time.ctime()[11:13] + time.ctime()[14:16]\n    return \"{}:{}\".format(n[0:2], n[2:])\ndef run_b4sd_simulator(delay, callback, stop_event, publish_event, settings):\n    while True:\n        time_value = generate_value()\n        callback(time_value, publish_event, settings)\n        if stop_event.is_set():\n            break\n        time.sleep(delay)",
        "detail": "project.simulations.b4sd",
        "documentation": {}
    },
    {
        "label": "run_b4sd_simulator",
        "kind": 2,
        "importPath": "project.simulations.b4sd",
        "description": "project.simulations.b4sd",
        "peekOfCode": "def run_b4sd_simulator(delay, callback, stop_event, publish_event, settings):\n    while True:\n        time_value = generate_value()\n        callback(time_value, publish_event, settings)\n        if stop_event.is_set():\n            break\n        time.sleep(delay)",
        "detail": "project.simulations.b4sd",
        "documentation": {}
    },
    {
        "label": "generate_value",
        "kind": 2,
        "importPath": "project.simulations.button",
        "description": "project.simulations.button",
        "peekOfCode": "def generate_value(delay, previous_value=False):\n    while True:\n        time.sleep(delay)\n        new_value = random.randint(1, 2) == 2\n        if new_value == previous_value:\n            continue\n        else:\n            previous_value = new_value\n            yield new_value\ndef run_button_simulator(delay, callback_pressed, callback_released, stop_event, publish_event, settings):",
        "detail": "project.simulations.button",
        "documentation": {}
    },
    {
        "label": "run_button_simulator",
        "kind": 2,
        "importPath": "project.simulations.button",
        "description": "project.simulations.button",
        "peekOfCode": "def run_button_simulator(delay, callback_pressed, callback_released, stop_event, publish_event, settings):\n    for pressed in generate_value(delay):\n        if pressed:\n            callback_pressed(publish_event, settings)\n        else:\n            callback_released(publish_event, settings)\n        if stop_event.is_set():\n            break",
        "detail": "project.simulations.button",
        "documentation": {}
    },
    {
        "label": "play_sound",
        "kind": 2,
        "importPath": "project.simulations.buzzer",
        "description": "project.simulations.buzzer",
        "peekOfCode": "def play_sound(delay):\n    print(\"BIBI\")\n    # try:\n    #     import winsound\n    # except ImportError:\n    #     import os\n    #     def playsound(frequency, duration):\n    #         os.system('beep -f %s -l %s' % (frequency, duration))\n    # else:\n    #     def playsound(frequency, duration):",
        "detail": "project.simulations.buzzer",
        "documentation": {}
    },
    {
        "label": "run_buzzer_simulator",
        "kind": 2,
        "importPath": "project.simulations.buzzer",
        "description": "project.simulations.buzzer",
        "peekOfCode": "def run_buzzer_simulator(delay, callback_activated, callback_deactivated, stop_event, publish_event, settings):\n    callback_activated(publish_event, settings)\n    while True:\n        play_sound(delay)\n        if stop_event.is_set():\n            callback_deactivated(publish_event, settings)\n            break\n        time.sleep(delay)",
        "detail": "project.simulations.buzzer",
        "documentation": {}
    },
    {
        "label": "generate_values",
        "kind": 2,
        "importPath": "project.simulations.dht",
        "description": "project.simulations.dht",
        "peekOfCode": "def generate_values(initial_temp=25, initial_humidity=20):\n    temperature = initial_temp\n    humidity = initial_humidity\n    while True:\n        temperature = temperature + random.randint(-1, 1)\n        humidity = humidity + random.randint(-1, 1)\n        if humidity < 0:\n            humidity = 0\n        if humidity > 100:\n            humidity = 100",
        "detail": "project.simulations.dht",
        "documentation": {}
    },
    {
        "label": "run_dht_simulator",
        "kind": 2,
        "importPath": "project.simulations.dht",
        "description": "project.simulations.dht",
        "peekOfCode": "def run_dht_simulator(delay, callback, stop_event, publish_event, settings):\n    for h, t in generate_values():\n        time.sleep(delay)  \n        callback(h, t, publish_event, settings)\n        if stop_event.is_set():\n            break",
        "detail": "project.simulations.dht",
        "documentation": {}
    },
    {
        "label": "run_dioda_simulator",
        "kind": 2,
        "importPath": "project.simulations.dioda",
        "description": "project.simulations.dioda",
        "peekOfCode": "def run_dioda_simulator(pipe, delay, callback, stop_event, publish_event, settings):\n    last_dioda_time = time.time()\n    while True:\n        if pipe.poll():\n            message = pipe.recv()\n            message = str(message).strip().lower()\n            if message == \"l\":\n                last_dioda_time = time.time()\n        dioda_state = time.time() - last_dioda_time <= 10\n        time.sleep(delay)  ",
        "detail": "project.simulations.dioda",
        "documentation": {}
    },
    {
        "label": "generate_values",
        "kind": 2,
        "importPath": "project.simulations.gyro",
        "description": "project.simulations.gyro",
        "peekOfCode": "def generate_values():\n    while True:\n        accel_x = random.uniform(-32768, 32767)\n        gyro_x = random.uniform(-32768, 32767)\n        accel_y = random.uniform(-32768, 32767)\n        gyro_y = random.uniform(-32768, 32767)\n        accel_z = random.uniform(-32768, 32767)\n        gyro_z = random.uniform(-32768, 32767)\n        accel_tuple = (accel_x, accel_y, accel_z)\n        gyro_tuple = (gyro_x, gyro_y, gyro_z)",
        "detail": "project.simulations.gyro",
        "documentation": {}
    },
    {
        "label": "run_gyro_simulator",
        "kind": 2,
        "importPath": "project.simulations.gyro",
        "description": "project.simulations.gyro",
        "peekOfCode": "def run_gyro_simulator(delay, callback, stop_event, publish_event, settings):\n    for accel, gyro in generate_values():\n        callback(accel, gyro, publish_event, settings)\n        if stop_event.is_set():\n            break\n        time.sleep(delay)",
        "detail": "project.simulations.gyro",
        "documentation": {}
    },
    {
        "label": "on_connect",
        "kind": 2,
        "importPath": "project.simulations.lcd",
        "description": "project.simulations.lcd",
        "peekOfCode": "def on_connect(client, userdata, flags, rc):\n    client.subscribe(\"data/temperature\")\n    client.subscribe(\"data/humidity\")\ndef update_data(topic, data):\n    global humidity, temperature\n    if data[\"name\"] == DHT_NAME:\n        if topic == \"data/temperature\":\n            temperature = data[\"value\"]\n        elif topic == \"data/humidity\":\n            humidity = data[\"value\"]",
        "detail": "project.simulations.lcd",
        "documentation": {}
    },
    {
        "label": "update_data",
        "kind": 2,
        "importPath": "project.simulations.lcd",
        "description": "project.simulations.lcd",
        "peekOfCode": "def update_data(topic, data):\n    global humidity, temperature\n    if data[\"name\"] == DHT_NAME:\n        if topic == \"data/temperature\":\n            temperature = data[\"value\"]\n        elif topic == \"data/humidity\":\n            humidity = data[\"value\"]\ndef connect_mqtt(hostname,port):\n    mqtt_client = mqtt.Client()\n    mqtt_client.connect(hostname,port, 60)",
        "detail": "project.simulations.lcd",
        "documentation": {}
    },
    {
        "label": "connect_mqtt",
        "kind": 2,
        "importPath": "project.simulations.lcd",
        "description": "project.simulations.lcd",
        "peekOfCode": "def connect_mqtt(hostname,port):\n    mqtt_client = mqtt.Client()\n    mqtt_client.connect(hostname,port, 60)\n    mqtt_client.loop_start()\n    mqtt_client.on_connect = on_connect\n    mqtt_client.on_message = lambda client, userdata, msg: update_data(msg.topic, json.loads(msg.payload.decode('utf-8')))\ndef run_lcd_simulator(delay, callback, stop_event, settings,hostname,port):\n    connect_mqtt(hostname,port)\n    while True:\n        callback(humidity, temperature, settings)",
        "detail": "project.simulations.lcd",
        "documentation": {}
    },
    {
        "label": "run_lcd_simulator",
        "kind": 2,
        "importPath": "project.simulations.lcd",
        "description": "project.simulations.lcd",
        "peekOfCode": "def run_lcd_simulator(delay, callback, stop_event, settings,hostname,port):\n    connect_mqtt(hostname,port)\n    while True:\n        callback(humidity, temperature, settings)\n        if stop_event.is_set():\n            break\n        time.sleep(delay)",
        "detail": "project.simulations.lcd",
        "documentation": {}
    },
    {
        "label": "humidity",
        "kind": 5,
        "importPath": "project.simulations.lcd",
        "description": "project.simulations.lcd",
        "peekOfCode": "humidity = 0\ntemperature = 0\nDHT_NAME = \"GDHT\"\ndef on_connect(client, userdata, flags, rc):\n    client.subscribe(\"data/temperature\")\n    client.subscribe(\"data/humidity\")\ndef update_data(topic, data):\n    global humidity, temperature\n    if data[\"name\"] == DHT_NAME:\n        if topic == \"data/temperature\":",
        "detail": "project.simulations.lcd",
        "documentation": {}
    },
    {
        "label": "temperature",
        "kind": 5,
        "importPath": "project.simulations.lcd",
        "description": "project.simulations.lcd",
        "peekOfCode": "temperature = 0\nDHT_NAME = \"GDHT\"\ndef on_connect(client, userdata, flags, rc):\n    client.subscribe(\"data/temperature\")\n    client.subscribe(\"data/humidity\")\ndef update_data(topic, data):\n    global humidity, temperature\n    if data[\"name\"] == DHT_NAME:\n        if topic == \"data/temperature\":\n            temperature = data[\"value\"]",
        "detail": "project.simulations.lcd",
        "documentation": {}
    },
    {
        "label": "DHT_NAME",
        "kind": 5,
        "importPath": "project.simulations.lcd",
        "description": "project.simulations.lcd",
        "peekOfCode": "DHT_NAME = \"GDHT\"\ndef on_connect(client, userdata, flags, rc):\n    client.subscribe(\"data/temperature\")\n    client.subscribe(\"data/humidity\")\ndef update_data(topic, data):\n    global humidity, temperature\n    if data[\"name\"] == DHT_NAME:\n        if topic == \"data/temperature\":\n            temperature = data[\"value\"]\n        elif topic == \"data/humidity\":",
        "detail": "project.simulations.lcd",
        "documentation": {}
    },
    {
        "label": "generate_values",
        "kind": 2,
        "importPath": "project.simulations.ms",
        "description": "project.simulations.ms",
        "peekOfCode": "def generate_values():\n    while True:\n        if random.randint(0, 10) != 0:\n            length = random.randint(4, 8)\n            code = ''.join(random.choices(keys, k=length))\n        else:\n            code = pin\n        yield code\ndef run_ms_simulator(delay, callback, stop_event, publish_event, settings):\n    for code in generate_values():",
        "detail": "project.simulations.ms",
        "documentation": {}
    },
    {
        "label": "run_ms_simulator",
        "kind": 2,
        "importPath": "project.simulations.ms",
        "description": "project.simulations.ms",
        "peekOfCode": "def run_ms_simulator(delay, callback, stop_event, publish_event, settings):\n    for code in generate_values():\n        time.sleep(delay) \n        callback(code, publish_event, settings)\n        if stop_event.is_set():\n            break",
        "detail": "project.simulations.ms",
        "documentation": {}
    },
    {
        "label": "keys",
        "kind": 5,
        "importPath": "project.simulations.ms",
        "description": "project.simulations.ms",
        "peekOfCode": "keys = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"*\", \"#\", \"A\", \"B\", \"C\", \"D\"]\npin = \"1234\"\ndef generate_values():\n    while True:\n        if random.randint(0, 10) != 0:\n            length = random.randint(4, 8)\n            code = ''.join(random.choices(keys, k=length))\n        else:\n            code = pin\n        yield code",
        "detail": "project.simulations.ms",
        "documentation": {}
    },
    {
        "label": "pin",
        "kind": 5,
        "importPath": "project.simulations.ms",
        "description": "project.simulations.ms",
        "peekOfCode": "pin = \"1234\"\ndef generate_values():\n    while True:\n        if random.randint(0, 10) != 0:\n            length = random.randint(4, 8)\n            code = ''.join(random.choices(keys, k=length))\n        else:\n            code = pin\n        yield code\ndef run_ms_simulator(delay, callback, stop_event, publish_event, settings):",
        "detail": "project.simulations.ms",
        "documentation": {}
    },
    {
        "label": "generate_value",
        "kind": 2,
        "importPath": "project.simulations.pir",
        "description": "project.simulations.pir",
        "peekOfCode": "def generate_value():\n    return random.randint(0, 1) == 1\ndef run_pir_simulator(delay, callback, stop_event, publish_event, settings):\n    while True:\n        motion_detected = generate_value()\n        time.sleep(delay) \n        if motion_detected:\n            callback(publish_event, settings, 1)\n        else:\n            callback(publish_event, settings, 0)",
        "detail": "project.simulations.pir",
        "documentation": {}
    },
    {
        "label": "run_pir_simulator",
        "kind": 2,
        "importPath": "project.simulations.pir",
        "description": "project.simulations.pir",
        "peekOfCode": "def run_pir_simulator(delay, callback, stop_event, publish_event, settings):\n    while True:\n        motion_detected = generate_value()\n        time.sleep(delay) \n        if motion_detected:\n            callback(publish_event, settings, 1)\n        else:\n            callback(publish_event, settings, 0)\n        if stop_event.is_set():\n            break",
        "detail": "project.simulations.pir",
        "documentation": {}
    },
    {
        "label": "map_color",
        "kind": 2,
        "importPath": "project.simulations.rgb",
        "description": "project.simulations.rgb",
        "peekOfCode": "def map_color(key):\n    if key == \"1\":\n        return \"red\"\n    elif key == \"2\":\n        return \"green\"\n    elif key == \"3\":\n        return \"blue\"\n    elif key == \"4\":\n        return \"yellow\"\n    elif key == \"5\":",
        "detail": "project.simulations.rgb",
        "documentation": {}
    },
    {
        "label": "on_connect",
        "kind": 2,
        "importPath": "project.simulations.rgb",
        "description": "project.simulations.rgb",
        "peekOfCode": "def on_connect(client, userdata, flags, rc):\n    client.subscribe(\"data/ir\")\n    client.subscribe(\"front-rgb\")\ndef update_data(topic, data):\n    global new_action\n    print(\"rgb data: \", data, \"received from topic \" + topic)\n    new_action = map_color(data[\"value\"])\ndef connect_mqtt(hostname,port):\n    mqtt_client = mqtt.Client()\n    mqtt_client.connect(hostname,port, 60)",
        "detail": "project.simulations.rgb",
        "documentation": {}
    },
    {
        "label": "update_data",
        "kind": 2,
        "importPath": "project.simulations.rgb",
        "description": "project.simulations.rgb",
        "peekOfCode": "def update_data(topic, data):\n    global new_action\n    print(\"rgb data: \", data, \"received from topic \" + topic)\n    new_action = map_color(data[\"value\"])\ndef connect_mqtt(hostname,port):\n    mqtt_client = mqtt.Client()\n    mqtt_client.connect(hostname,port, 60)\n    mqtt_client.loop_start()\n    mqtt_client.on_connect = on_connect\n    mqtt_client.on_message = lambda client, userdata, msg: update_data(msg.topic, json.loads(msg.payload.decode('utf-8')))",
        "detail": "project.simulations.rgb",
        "documentation": {}
    },
    {
        "label": "connect_mqtt",
        "kind": 2,
        "importPath": "project.simulations.rgb",
        "description": "project.simulations.rgb",
        "peekOfCode": "def connect_mqtt(hostname,port):\n    mqtt_client = mqtt.Client()\n    mqtt_client.connect(hostname,port, 60)\n    mqtt_client.loop_start()\n    mqtt_client.on_connect = on_connect\n    mqtt_client.on_message = lambda client, userdata, msg: update_data(msg.topic, json.loads(msg.payload.decode('utf-8')))\ndef run_rgb_simulator(delay, callback, stop_event, publish_event, settings,hostname,port):\n    print(\"AAAAAAAAAAAAAAAA\")\n    connect_mqtt(hostname,port)\n    global status, new_action",
        "detail": "project.simulations.rgb",
        "documentation": {}
    },
    {
        "label": "run_rgb_simulator",
        "kind": 2,
        "importPath": "project.simulations.rgb",
        "description": "project.simulations.rgb",
        "peekOfCode": "def run_rgb_simulator(delay, callback, stop_event, publish_event, settings,hostname,port):\n    print(\"AAAAAAAAAAAAAAAA\")\n    connect_mqtt(hostname,port)\n    global status, new_action\n    while True:\n        if new_action != status:\n            status = new_action\n            callback(status, publish_event, settings)\n        if stop_event.is_set():\n            break",
        "detail": "project.simulations.rgb",
        "documentation": {}
    },
    {
        "label": "status",
        "kind": 5,
        "importPath": "project.simulations.rgb",
        "description": "project.simulations.rgb",
        "peekOfCode": "status = \"off\"\nnew_action = \"off\"\nall_states = [\"red\", \"green\", \"blue\", \"yellow\", \"purple\", \"lightBlue\", \"white\", \"off\"]\ndef map_color(key):\n    if key == \"1\":\n        return \"red\"\n    elif key == \"2\":\n        return \"green\"\n    elif key == \"3\":\n        return \"blue\"",
        "detail": "project.simulations.rgb",
        "documentation": {}
    },
    {
        "label": "new_action",
        "kind": 5,
        "importPath": "project.simulations.rgb",
        "description": "project.simulations.rgb",
        "peekOfCode": "new_action = \"off\"\nall_states = [\"red\", \"green\", \"blue\", \"yellow\", \"purple\", \"lightBlue\", \"white\", \"off\"]\ndef map_color(key):\n    if key == \"1\":\n        return \"red\"\n    elif key == \"2\":\n        return \"green\"\n    elif key == \"3\":\n        return \"blue\"\n    elif key == \"4\":",
        "detail": "project.simulations.rgb",
        "documentation": {}
    },
    {
        "label": "all_states",
        "kind": 5,
        "importPath": "project.simulations.rgb",
        "description": "project.simulations.rgb",
        "peekOfCode": "all_states = [\"red\", \"green\", \"blue\", \"yellow\", \"purple\", \"lightBlue\", \"white\", \"off\"]\ndef map_color(key):\n    if key == \"1\":\n        return \"red\"\n    elif key == \"2\":\n        return \"green\"\n    elif key == \"3\":\n        return \"blue\"\n    elif key == \"4\":\n        return \"yellow\"",
        "detail": "project.simulations.rgb",
        "documentation": {}
    },
    {
        "label": "get_distance",
        "kind": 2,
        "importPath": "project.simulations.uds",
        "description": "project.simulations.uds",
        "peekOfCode": "def get_distance():\n    return random.uniform(0.0, 200.0)\ndef generate_values():\n    try:\n        while True:\n            distance = get_distance()\n            yield distance\n    except KeyboardInterrupt:\n        print('Measurement stopped by user')\n    except Exception as e:",
        "detail": "project.simulations.uds",
        "documentation": {}
    },
    {
        "label": "generate_values",
        "kind": 2,
        "importPath": "project.simulations.uds",
        "description": "project.simulations.uds",
        "peekOfCode": "def generate_values():\n    try:\n        while True:\n            distance = get_distance()\n            yield distance\n    except KeyboardInterrupt:\n        print('Measurement stopped by user')\n    except Exception as e:\n        print(f'Error: {str(e)}')\ndef run_uds_simulator(delay, callback, stop_event, publish_event, settings):",
        "detail": "project.simulations.uds",
        "documentation": {}
    },
    {
        "label": "run_uds_simulator",
        "kind": 2,
        "importPath": "project.simulations.uds",
        "description": "project.simulations.uds",
        "peekOfCode": "def run_uds_simulator(delay, callback, stop_event, publish_event, settings):\n    for distance in generate_values():\n        time.sleep(delay) \n        callback(distance, publish_event, settings)\n        if stop_event.is_set():\n            break",
        "detail": "project.simulations.uds",
        "documentation": {}
    },
    {
        "label": "on_connect",
        "kind": 2,
        "importPath": "project.main",
        "description": "project.main",
        "peekOfCode": "def on_connect(client, userdata, flags, rc):\n    client.subscribe(\"pi1\")\n    client.subscribe(\"front-bb-on\")\n    client.subscribe(\"front-bb-off\")\n    client.subscribe(\"pi3\")\nmqtt_client.on_connect = on_connect\nmqtt_client.on_message = lambda client, userdata, msg: update_data(msg.topic, json.loads(msg.payload.decode('utf-8')))\ndef connect_mqtt():\n    mqtt_client.connect(HOSTNAME, PORT, 60)\n    mqtt_client.loop_start()",
        "detail": "project.main",
        "documentation": {}
    },
    {
        "label": "connect_mqtt",
        "kind": 2,
        "importPath": "project.main",
        "description": "project.main",
        "peekOfCode": "def connect_mqtt():\n    mqtt_client.connect(HOSTNAME, PORT, 60)\n    mqtt_client.loop_start()\ndef menu():\n    print(\"=\" * 10 + \"  MENU  \" + \"=\" * 10)\n    print(\"-- Enter B to activate buzzer --\")\n    print(\"-- Enter D to deactivate buzzer --\")\n    print(\"-- Enter L to change light state --\")\n    print(\"-- Enter X to stop all devices --\")\n    print(\"=\" * 30)",
        "detail": "project.main",
        "documentation": {}
    },
    {
        "label": "menu",
        "kind": 2,
        "importPath": "project.main",
        "description": "project.main",
        "peekOfCode": "def menu():\n    print(\"=\" * 10 + \"  MENU  \" + \"=\" * 10)\n    print(\"-- Enter B to activate buzzer --\")\n    print(\"-- Enter D to deactivate buzzer --\")\n    print(\"-- Enter L to change light state --\")\n    print(\"-- Enter X to stop all devices --\")\n    print(\"=\" * 30)\ndef user_inputs(data):\n    global buzzer_active, db_settings\n    if data[\"trigger\"] == \"B\" and not buzzer_active:",
        "detail": "project.main",
        "documentation": {}
    },
    {
        "label": "user_inputs",
        "kind": 2,
        "importPath": "project.main",
        "description": "project.main",
        "peekOfCode": "def user_inputs(data):\n    global buzzer_active, db_settings\n    if data[\"trigger\"] == \"B\" and not buzzer_active:\n        print(\"BUZZER RADI\")\n        buzzer_stop_event.clear()\n        run_buzzer(db_settings, threads, buzzer_stop_event)\n        buzzer_active = True\n    elif data[\"trigger\"] == \"D\":\n        buzzer_stop_event.set()\n        buzzer_active = False",
        "detail": "project.main",
        "documentation": {}
    },
    {
        "label": "update_data",
        "kind": 2,
        "importPath": "project.main",
        "description": "project.main",
        "peekOfCode": "def update_data(topic, data):\n    print(\"bb data: \", data, \"received from topic \" + topic)\n    if topic == \"front-bb-on\":\n        global bb_alarm_time\n        bb_alarm_time = data[\"time\"]\n    elif topic == \"front-bb-off\":\n        buzzer_stop_event.set()\n    elif topic == \"pi3\":\n        user_inputs(data)\nfrom datetime import datetime, timedelta",
        "detail": "project.main",
        "documentation": {}
    },
    {
        "label": "run_alarm_clock",
        "kind": 2,
        "importPath": "project.main",
        "description": "project.main",
        "peekOfCode": "def run_alarm_clock(bb_settings, threads, buzzer_stop_event):\n    global mqtt_client, bb_alarm_time\n    is_active = False\n    time_difference = timedelta(seconds=7)\n    while True:\n        try:\n            # Ensure bb_alarm_time is properly formatted\n            try:\n                # Debug: print the time value\n                print(f\"Parsing time: '{bb_alarm_time}'\")",
        "detail": "project.main",
        "documentation": {}
    },
    {
        "label": "run_pi1",
        "kind": 2,
        "importPath": "project.main",
        "description": "project.main",
        "peekOfCode": "def run_pi1(settings, threads, stop_event, pi_light_pipe):\n    dht1_settings = settings.get('DHT1')\n    dht2_settings = settings.get('DHT2')\n    uds1_settings = settings.get('DUS1')\n    rpir1_settings = settings.get('RPIR1')\n    rpir2_settings = settings.get('RPIR2')\n    dpir1_settings = settings.get('DPIR1')\n    ds1_settings = settings.get('DS1')\n    ms_settings = settings.get('DMS')\n    db_settings = settings.get('DB')",
        "detail": "project.main",
        "documentation": {}
    },
    {
        "label": "run_pi2",
        "kind": 2,
        "importPath": "project.main",
        "description": "project.main",
        "peekOfCode": "def run_pi2(settings, threads, stop_event):\n    global HOSTNAME\n    global PORT\n    gdht_settings = settings.get('GDHT')\n    rdht3_settings = settings.get('RDHT3')\n    uds2_settings = settings.get('DUS2')\n    rpir3_settings = settings.get('RPIR3')\n    dpir2_settings = settings.get('DPIR2')\n    glcd_settings = settings.get('GLCD')\n    gsg_settings = settings.get('GSG')",
        "detail": "project.main",
        "documentation": {}
    },
    {
        "label": "run_pi3",
        "kind": 2,
        "importPath": "project.main",
        "description": "project.main",
        "peekOfCode": "def run_pi3(settings, threads, stop_event, buzzer_stop_event):\n    rdht4_settings = settings.get('RDHT4')\n    rpir4_settings = settings.get('RPIR4')\n    bb_settings = settings.get('BB')\n    bir_settings = settings.get('BIR')\n    brgb_settings = settings.get('BRGB')\n    b4sd_settings = settings.get('B4SD')\n    if rdht4_settings:\n        run_dht(rdht4_settings, threads, stop_event)\n    if rpir4_settings:",
        "detail": "project.main",
        "documentation": {}
    },
    {
        "label": "buzzer_stop_event",
        "kind": 5,
        "importPath": "project.main",
        "description": "project.main",
        "peekOfCode": "buzzer_stop_event = threading.Event()\nstop_event = threading.Event()\nmqtt_client = mqtt.Client()\nbuzzer_active = False\nbb_alarm_time = \"21:39\"\ndef on_connect(client, userdata, flags, rc):\n    client.subscribe(\"pi1\")\n    client.subscribe(\"front-bb-on\")\n    client.subscribe(\"front-bb-off\")\n    client.subscribe(\"pi3\")",
        "detail": "project.main",
        "documentation": {}
    },
    {
        "label": "stop_event",
        "kind": 5,
        "importPath": "project.main",
        "description": "project.main",
        "peekOfCode": "stop_event = threading.Event()\nmqtt_client = mqtt.Client()\nbuzzer_active = False\nbb_alarm_time = \"21:39\"\ndef on_connect(client, userdata, flags, rc):\n    client.subscribe(\"pi1\")\n    client.subscribe(\"front-bb-on\")\n    client.subscribe(\"front-bb-off\")\n    client.subscribe(\"pi3\")\nmqtt_client.on_connect = on_connect",
        "detail": "project.main",
        "documentation": {}
    },
    {
        "label": "mqtt_client",
        "kind": 5,
        "importPath": "project.main",
        "description": "project.main",
        "peekOfCode": "mqtt_client = mqtt.Client()\nbuzzer_active = False\nbb_alarm_time = \"21:39\"\ndef on_connect(client, userdata, flags, rc):\n    client.subscribe(\"pi1\")\n    client.subscribe(\"front-bb-on\")\n    client.subscribe(\"front-bb-off\")\n    client.subscribe(\"pi3\")\nmqtt_client.on_connect = on_connect\nmqtt_client.on_message = lambda client, userdata, msg: update_data(msg.topic, json.loads(msg.payload.decode('utf-8')))",
        "detail": "project.main",
        "documentation": {}
    },
    {
        "label": "buzzer_active",
        "kind": 5,
        "importPath": "project.main",
        "description": "project.main",
        "peekOfCode": "buzzer_active = False\nbb_alarm_time = \"21:39\"\ndef on_connect(client, userdata, flags, rc):\n    client.subscribe(\"pi1\")\n    client.subscribe(\"front-bb-on\")\n    client.subscribe(\"front-bb-off\")\n    client.subscribe(\"pi3\")\nmqtt_client.on_connect = on_connect\nmqtt_client.on_message = lambda client, userdata, msg: update_data(msg.topic, json.loads(msg.payload.decode('utf-8')))\ndef connect_mqtt():",
        "detail": "project.main",
        "documentation": {}
    },
    {
        "label": "bb_alarm_time",
        "kind": 5,
        "importPath": "project.main",
        "description": "project.main",
        "peekOfCode": "bb_alarm_time = \"21:39\"\ndef on_connect(client, userdata, flags, rc):\n    client.subscribe(\"pi1\")\n    client.subscribe(\"front-bb-on\")\n    client.subscribe(\"front-bb-off\")\n    client.subscribe(\"pi3\")\nmqtt_client.on_connect = on_connect\nmqtt_client.on_message = lambda client, userdata, msg: update_data(msg.topic, json.loads(msg.payload.decode('utf-8')))\ndef connect_mqtt():\n    mqtt_client.connect(HOSTNAME, PORT, 60)",
        "detail": "project.main",
        "documentation": {}
    },
    {
        "label": "mqtt_client.on_connect",
        "kind": 5,
        "importPath": "project.main",
        "description": "project.main",
        "peekOfCode": "mqtt_client.on_connect = on_connect\nmqtt_client.on_message = lambda client, userdata, msg: update_data(msg.topic, json.loads(msg.payload.decode('utf-8')))\ndef connect_mqtt():\n    mqtt_client.connect(HOSTNAME, PORT, 60)\n    mqtt_client.loop_start()\ndef menu():\n    print(\"=\" * 10 + \"  MENU  \" + \"=\" * 10)\n    print(\"-- Enter B to activate buzzer --\")\n    print(\"-- Enter D to deactivate buzzer --\")\n    print(\"-- Enter L to change light state --\")",
        "detail": "project.main",
        "documentation": {}
    },
    {
        "label": "mqtt_client.on_message",
        "kind": 5,
        "importPath": "project.main",
        "description": "project.main",
        "peekOfCode": "mqtt_client.on_message = lambda client, userdata, msg: update_data(msg.topic, json.loads(msg.payload.decode('utf-8')))\ndef connect_mqtt():\n    mqtt_client.connect(HOSTNAME, PORT, 60)\n    mqtt_client.loop_start()\ndef menu():\n    print(\"=\" * 10 + \"  MENU  \" + \"=\" * 10)\n    print(\"-- Enter B to activate buzzer --\")\n    print(\"-- Enter D to deactivate buzzer --\")\n    print(\"-- Enter L to change light state --\")\n    print(\"-- Enter X to stop all devices --\")",
        "detail": "project.main",
        "documentation": {}
    },
    {
        "label": "alarm_set_on",
        "kind": 2,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "def alarm_set_on():\n    print(\"ALARM\")\n    with app.app_context():\n        with lock:\n            global is_alarm\n            is_alarm = True\n            mqtt_client.publish(\"pi1\", json.dumps({\"trigger\": \"B\"}))\n            mqtt_client.publish(\"pi3\", json.dumps({\"trigger\": \"B\"}))\n            point = (\n                Point(\"Alarm\")",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "alarm_set_off",
        "kind": 2,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "def alarm_set_off():\n    with app.app_context():\n        with lock:\n            global is_alarm\n            is_alarm = False\n            mqtt_client.publish(\"pi1\", json.dumps({\"trigger\": \"D\"}))\n            mqtt_client.publish(\"pi3\", json.dumps({\"trigger\": \"D\"}))\n            point = (\n                Point(\"Alarm\")\n                .tag(\"name\", \"triggered\")",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "handle_connect",
        "kind": 2,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "def handle_connect():\n    print('Client connected successfully\\n')\n@socketio.on('disconnect')\ndef handle_disconnect():\n    print('Client disconnected successfully\\n')\ndef send_data_to_client(data):\n    try:\n        socketio.emit('data', {'message': data})\n    except Exception as e:\n        print(e)",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "handle_disconnect",
        "kind": 2,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "def handle_disconnect():\n    print('Client disconnected successfully\\n')\ndef send_data_to_client(data):\n    try:\n        socketio.emit('data', {'message': data})\n    except Exception as e:\n        print(e)\ndef send_alarm_to_client():\n    global is_alarm\n    try:",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "send_data_to_client",
        "kind": 2,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "def send_data_to_client(data):\n    try:\n        socketio.emit('data', {'message': data})\n    except Exception as e:\n        print(e)\ndef send_alarm_to_client():\n    global is_alarm\n    try:\n        socketio.emit('alarm', {'message': is_alarm})\n    except Exception as e:",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "send_alarm_to_client",
        "kind": 2,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "def send_alarm_to_client():\n    global is_alarm\n    try:\n        socketio.emit('alarm', {'message': is_alarm})\n    except Exception as e:\n        print(e)\ndef on_connect(client, userdata, flags, rc):\n    print(\"Connected to MQTT broker with result code \" + str(rc))\n    client.subscribe(\"data/+\")\nmqtt_client.on_connect = on_connect",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "on_connect",
        "kind": 2,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "def on_connect(client, userdata, flags, rc):\n    print(\"Connected to MQTT broker with result code \" + str(rc))\n    client.subscribe(\"data/+\")\nmqtt_client.on_connect = on_connect\nmqtt_client.on_message = lambda client, userdata, msg: save_to_db(msg.topic, json.loads(msg.payload.decode('utf-8')))\ndef laj_koji_pase_ne_ujeda():\n    global last_pressed_ds1\n    global last_pressed_ds2\n    global security_timestamp\n    global house_keep",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "laj_koji_pase_ne_ujeda",
        "kind": 2,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "def laj_koji_pase_ne_ujeda():\n    global last_pressed_ds1\n    global last_pressed_ds2\n    global security_timestamp\n    global house_keep\n    while True:\n        if house_keep:\n            if last_pressed_ds1 > 0 and time.time() - last_pressed_ds1 > 5 and last_released_ds1 <= last_pressed_ds1:\n                alarm_set_on()\n            if last_pressed_ds2 > 0 and time.time() - last_pressed_ds2 > 5 and last_released_ds2 <= last_pressed_ds2:",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "adjust_people_count",
        "kind": 2,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "def adjust_people_count(device_number=1):\n    with app.app_context():\n        query = (f'from(bucket: \"{bucket}\") |> range(start: -5s, stop: now()) |> filter(fn: ('\n                 f'r) => r[\"_measurement\"] == \"UDS\") |> filter(fn: (r) => r[\"name\"] == \"DUS{device_number}\") '\n                 f' |> yield(name: \"last\")')\n        response = handle_influx_query(query)\n        try:\n            values = json.loads(response.data.decode('utf-8'))['data']\n        except KeyError:\n            print(\"Key 'data' not found in the response\")",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "check_safe_movement",
        "kind": 2,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "def check_safe_movement(data):\n    with app.app_context():\n        axis = str(data[\"axis\"])\n        query = (f'from(bucket: \"{bucket}\") |> range(start: -10s, stop: now())'\n                 '|> filter(fn: (r) => r[\"_measurement\"] == \"Gyroscope\")'\n                 '|> filter(fn: (r) => r[\"name\"] == \"GSG\")'\n                 f'|> filter(fn: (r) => r[\"axis\"] == \"{axis}\")'\n                 '|> aggregateWindow(every: 5s, fn: last, createEmpty: false)'\n                 '|> yield(name: \"last\")')\n        response = handle_influx_query(query)",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "rpir_raise_alarm",
        "kind": 2,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "def rpir_raise_alarm():\n    with app.app_context():\n        global is_alarm\n        global in_house_count\n        global house_keep\n        if in_house_count == 0 and house_keep:\n            alarm_set_on()\ndef ds_adjust_time(data, device_number=1):\n    if data[\"value\"] == \"pressed\":\n        if device_number == 1:",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "ds_adjust_time",
        "kind": 2,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "def ds_adjust_time(data, device_number=1):\n    if data[\"value\"] == \"pressed\":\n        if device_number == 1:\n            with lock:\n                global last_pressed_ds1\n                last_pressed_ds1 = time.time()\n        else:\n            with lock:\n                global last_pressed_ds2\n                last_pressed_ds2 = time.time()",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "handle_pin_input",
        "kind": 2,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "def handle_pin_input(pin):\n    with app.app_context():\n        if pin == correct_pin:\n            global is_alarm\n            global security_timestamp\n            if is_alarm:\n                alarm_set_off()\n            if security_timestamp == 0:\n                with lock:\n                    security_timestamp = time.time() + 10",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "command_callback",
        "kind": 2,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "def command_callback(data):\n    if data[\"name\"] == \"DPIR1\" and data['value'] == \"detected\":\n        mqtt_client.publish(\"pi1\", json.dumps({\"trigger\": \"L\"}))\n        adjust_people_count()\n    if data[\"name\"] == \"DPIR2\" and data['value'] == \"detected\":\n        adjust_people_count(2)\n    if data[\"name\"] == \"GSG\":\n        check_safe_movement(data)\n    if data['value'] == \"detected\" and (\n            data[\"name\"] == \"RPIR1\" or data[\"name\"] == \"RPIR2\" or data[\"name\"] == \"RPIR3\" or data[\"name\"] == \"RPIR4\"):",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "save_to_db",
        "kind": 2,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "def save_to_db(topic, data):\n    write_api = influxdb_client.write_api(write_options=SYNCHRONOUS)\n    if isinstance(data[\"value\"], int):\n        data[\"value\"] = float(data[\"value\"])\n    if topic == \"data/acceleration\" or topic == \"data/gyroscope\":\n        point = (\n            Point(data[\"measurement\"])\n            .tag(\"simulated\", data[\"simulated\"])\n            .tag(\"runs_on\", data[\"runs_on\"])\n            .tag(\"name\", data[\"name\"])",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "handle_influx_query",
        "kind": 2,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "def handle_influx_query(query):\n    try:\n        query_api = influxdb_client.query_api()\n        tables = query_api.query(query, org=org)\n        container = []\n        for table in tables:\n            for record in table.records:\n                container.append(record.values)\n        return jsonify({\"status\": \"success\", \"data\": container})\n    except Exception as e:",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "extract_filtered_device_info",
        "kind": 2,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "def extract_filtered_device_info():\n    settings = load_settings()\n    filtered_info = {\n        key: {\n            \"name\": device_info[\"name\"],\n            \"simulated\": device_info[\"simulated\"],\n            \"pin\": device_info.get(\"pin\", None),\n            \"runs_on\": device_info[\"runs_on\"]\n        }\n        for key, device_info in settings.items()",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "retrieve_filtered_device_info",
        "kind": 2,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "def retrieve_filtered_device_info():\n    filtered_device_info = extract_filtered_device_info()\n    print(filtered_device_info)\n    return jsonify(filtered_device_info)\n@app.route('/api/active', methods=['GET'])\n@cross_origin()\ndef active_system():\n    global house_keep\n    house_keep = True\n    print(\"System activated\")",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "active_system",
        "kind": 2,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "def active_system():\n    global house_keep\n    house_keep = True\n    print(\"System activated\")\n    return jsonify({\"status\": \"success\", \"message\": \"System activated\"})\n@app.route('/api/deactive', methods=['GET'])\n@cross_origin()\ndef deactive_system():\n    global house_keep\n    house_keep = False",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "deactive_system",
        "kind": 2,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "def deactive_system():\n    global house_keep\n    house_keep = False\n    print(\"System deactivated\")\n    return jsonify({\"status\": \"success\", \"message\": \"System deactivated\"})\n@app.route('/api/device_values', methods=['GET'])\n@cross_origin()\ndef retrieve_device_values():\n    query = f'from(bucket: \"{bucket}\") |> range(start: -5m) |> filter(fn: (r) => r[\"_measurement\"] != \"Alarm\") |> last()'\n    response = handle_influx_query(query)",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "retrieve_device_values",
        "kind": 2,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "def retrieve_device_values():\n    query = f'from(bucket: \"{bucket}\") |> range(start: -5m) |> filter(fn: (r) => r[\"_measurement\"] != \"Alarm\") |> last()'\n    response = handle_influx_query(query)\n    values = json.loads(response.data.decode('utf-8'))['data']\n    device_values = {}\n    for value in values:\n        device_name = value[\"name\"]\n        device_values[device_name] = {\n            \"value\": value[\"_value\"],\n            \"measurement\": value[\"_measurement\"],",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "update_rgb",
        "kind": 2,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "def update_rgb(color):\n    print(color)\n    rgb_topic = \"front-rgb\"\n    payload = json.dumps({\"value\": color})\n    mqtt_client.publish(rgb_topic, payload)\n    return payload\n@app.route('/api/getAlarmClock', methods=['GET'])\n@cross_origin()\ndef get_alarm_clock():\n    print(\"api to get alarm clock\")",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "get_alarm_clock",
        "kind": 2,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "def get_alarm_clock():\n    print(\"api to get alarm clock\")\n    payload = json.dumps({\"time\": bb_alarm_time})\n    return payload\n@app.route('/api/setAlarmClock', methods=['PUT'])\n@cross_origin()\ndef set_alarm_clock():\n    global bb_alarm_time\n    try:\n        data = request.json",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "set_alarm_clock",
        "kind": 2,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "def set_alarm_clock():\n    global bb_alarm_time\n    try:\n        data = request.json\n        bb_alarm_time = data.get('time').strip()  # Trimovanje eventualnih belih znakova\n        # Validate and sanitize time format\n        try:\n            # Debug: print the time value\n            print(f\"Received time: '{bb_alarm_time}'\")\n            datetime.strptime(bb_alarm_time, \"%H:%M\")",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "input_pin",
        "kind": 2,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "def input_pin():\n    try:\n        data = request.json\n        pin = data.get('pin')\n        print(\"Pin entered: \", pin)\n        handle_pin_input(pin)\n        return jsonify({'message': 'Pin entered successfully'})\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n@app.route('/api/turnOffAlarmClock', methods=['GET'])",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "turn_off_alarm_clock",
        "kind": 2,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "def turn_off_alarm_clock():\n    try:\n        print(\"turn off alarm clock\")\n        bb_topic = \"front-bb-off\"\n        payload = json.dumps({\"time\": \"\"})\n        mqtt_client.publish(bb_topic, payload)\n        return jsonify({'message': 'Alarm time turned off successfully'})\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\nif __name__ == '__main__':",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "app = Flask(__name__)\nCORS(app)\nsocketio = SocketIO(app, cors_allowed_origins=\"http://localhost:3001\", async_mode='threading')\n# InfluxDB Configuration\ntoken = os.getenv(\"INFLUXDB_TOKEN\")\norg = os.getenv(\"ORGANIZATION\")\nurl = os.getenv(\"URL\")\nbucket = os.getenv(\"BUCKET_NAME\")\ninfluxdb_client = InfluxDBClient(url=url, token=token, org=org)\nmqtt_client = mqtt.Client()",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "socketio",
        "kind": 5,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "socketio = SocketIO(app, cors_allowed_origins=\"http://localhost:3001\", async_mode='threading')\n# InfluxDB Configuration\ntoken = os.getenv(\"INFLUXDB_TOKEN\")\norg = os.getenv(\"ORGANIZATION\")\nurl = os.getenv(\"URL\")\nbucket = os.getenv(\"BUCKET_NAME\")\ninfluxdb_client = InfluxDBClient(url=url, token=token, org=org)\nmqtt_client = mqtt.Client()\nmqtt_client.connect(\"localhost\", 1883, 0)\nmqtt_client.loop_start()",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "token",
        "kind": 5,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "token = os.getenv(\"INFLUXDB_TOKEN\")\norg = os.getenv(\"ORGANIZATION\")\nurl = os.getenv(\"URL\")\nbucket = os.getenv(\"BUCKET_NAME\")\ninfluxdb_client = InfluxDBClient(url=url, token=token, org=org)\nmqtt_client = mqtt.Client()\nmqtt_client.connect(\"localhost\", 1883, 0)\nmqtt_client.loop_start()\nin_house_count = 0\nis_alarm = False",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "org",
        "kind": 5,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "org = os.getenv(\"ORGANIZATION\")\nurl = os.getenv(\"URL\")\nbucket = os.getenv(\"BUCKET_NAME\")\ninfluxdb_client = InfluxDBClient(url=url, token=token, org=org)\nmqtt_client = mqtt.Client()\nmqtt_client.connect(\"localhost\", 1883, 0)\nmqtt_client.loop_start()\nin_house_count = 0\nis_alarm = False\nhouse_keep = False",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "url",
        "kind": 5,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "url = os.getenv(\"URL\")\nbucket = os.getenv(\"BUCKET_NAME\")\ninfluxdb_client = InfluxDBClient(url=url, token=token, org=org)\nmqtt_client = mqtt.Client()\nmqtt_client.connect(\"localhost\", 1883, 0)\nmqtt_client.loop_start()\nin_house_count = 0\nis_alarm = False\nhouse_keep = False\nlock = threading.Lock()",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "bucket",
        "kind": 5,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "bucket = os.getenv(\"BUCKET_NAME\")\ninfluxdb_client = InfluxDBClient(url=url, token=token, org=org)\nmqtt_client = mqtt.Client()\nmqtt_client.connect(\"localhost\", 1883, 0)\nmqtt_client.loop_start()\nin_house_count = 0\nis_alarm = False\nhouse_keep = False\nlock = threading.Lock()\nlast_pressed_ds1 = 0",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "influxdb_client",
        "kind": 5,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "influxdb_client = InfluxDBClient(url=url, token=token, org=org)\nmqtt_client = mqtt.Client()\nmqtt_client.connect(\"localhost\", 1883, 0)\nmqtt_client.loop_start()\nin_house_count = 0\nis_alarm = False\nhouse_keep = False\nlock = threading.Lock()\nlast_pressed_ds1 = 0\nlast_released_ds1 = 0",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "mqtt_client",
        "kind": 5,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "mqtt_client = mqtt.Client()\nmqtt_client.connect(\"localhost\", 1883, 0)\nmqtt_client.loop_start()\nin_house_count = 0\nis_alarm = False\nhouse_keep = False\nlock = threading.Lock()\nlast_pressed_ds1 = 0\nlast_released_ds1 = 0\nlast_pressed_ds2 = 0",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "in_house_count",
        "kind": 5,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "in_house_count = 0\nis_alarm = False\nhouse_keep = False\nlock = threading.Lock()\nlast_pressed_ds1 = 0\nlast_released_ds1 = 0\nlast_pressed_ds2 = 0\nlast_released_ds2 = 0\ncorrect_pin = \"1234\"\nsecurity_timestamp = time.time()",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "is_alarm",
        "kind": 5,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "is_alarm = False\nhouse_keep = False\nlock = threading.Lock()\nlast_pressed_ds1 = 0\nlast_released_ds1 = 0\nlast_pressed_ds2 = 0\nlast_released_ds2 = 0\ncorrect_pin = \"1234\"\nsecurity_timestamp = time.time()\nlast_correct_pin = 0",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "house_keep",
        "kind": 5,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "house_keep = False\nlock = threading.Lock()\nlast_pressed_ds1 = 0\nlast_released_ds1 = 0\nlast_pressed_ds2 = 0\nlast_released_ds2 = 0\ncorrect_pin = \"1234\"\nsecurity_timestamp = time.time()\nlast_correct_pin = 0\nbb_alarm_time = \"21:39\"",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "lock",
        "kind": 5,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "lock = threading.Lock()\nlast_pressed_ds1 = 0\nlast_released_ds1 = 0\nlast_pressed_ds2 = 0\nlast_released_ds2 = 0\ncorrect_pin = \"1234\"\nsecurity_timestamp = time.time()\nlast_correct_pin = 0\nbb_alarm_time = \"21:39\"\ndef alarm_set_on():",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "last_pressed_ds1",
        "kind": 5,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "last_pressed_ds1 = 0\nlast_released_ds1 = 0\nlast_pressed_ds2 = 0\nlast_released_ds2 = 0\ncorrect_pin = \"1234\"\nsecurity_timestamp = time.time()\nlast_correct_pin = 0\nbb_alarm_time = \"21:39\"\ndef alarm_set_on():\n    print(\"ALARM\")",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "last_released_ds1",
        "kind": 5,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "last_released_ds1 = 0\nlast_pressed_ds2 = 0\nlast_released_ds2 = 0\ncorrect_pin = \"1234\"\nsecurity_timestamp = time.time()\nlast_correct_pin = 0\nbb_alarm_time = \"21:39\"\ndef alarm_set_on():\n    print(\"ALARM\")\n    with app.app_context():",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "last_pressed_ds2",
        "kind": 5,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "last_pressed_ds2 = 0\nlast_released_ds2 = 0\ncorrect_pin = \"1234\"\nsecurity_timestamp = time.time()\nlast_correct_pin = 0\nbb_alarm_time = \"21:39\"\ndef alarm_set_on():\n    print(\"ALARM\")\n    with app.app_context():\n        with lock:",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "last_released_ds2",
        "kind": 5,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "last_released_ds2 = 0\ncorrect_pin = \"1234\"\nsecurity_timestamp = time.time()\nlast_correct_pin = 0\nbb_alarm_time = \"21:39\"\ndef alarm_set_on():\n    print(\"ALARM\")\n    with app.app_context():\n        with lock:\n            global is_alarm",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "correct_pin",
        "kind": 5,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "correct_pin = \"1234\"\nsecurity_timestamp = time.time()\nlast_correct_pin = 0\nbb_alarm_time = \"21:39\"\ndef alarm_set_on():\n    print(\"ALARM\")\n    with app.app_context():\n        with lock:\n            global is_alarm\n            is_alarm = True",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "security_timestamp",
        "kind": 5,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "security_timestamp = time.time()\nlast_correct_pin = 0\nbb_alarm_time = \"21:39\"\ndef alarm_set_on():\n    print(\"ALARM\")\n    with app.app_context():\n        with lock:\n            global is_alarm\n            is_alarm = True\n            mqtt_client.publish(\"pi1\", json.dumps({\"trigger\": \"B\"}))",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "last_correct_pin",
        "kind": 5,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "last_correct_pin = 0\nbb_alarm_time = \"21:39\"\ndef alarm_set_on():\n    print(\"ALARM\")\n    with app.app_context():\n        with lock:\n            global is_alarm\n            is_alarm = True\n            mqtt_client.publish(\"pi1\", json.dumps({\"trigger\": \"B\"}))\n            mqtt_client.publish(\"pi3\", json.dumps({\"trigger\": \"B\"}))",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "bb_alarm_time",
        "kind": 5,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "bb_alarm_time = \"21:39\"\ndef alarm_set_on():\n    print(\"ALARM\")\n    with app.app_context():\n        with lock:\n            global is_alarm\n            is_alarm = True\n            mqtt_client.publish(\"pi1\", json.dumps({\"trigger\": \"B\"}))\n            mqtt_client.publish(\"pi3\", json.dumps({\"trigger\": \"B\"}))\n            point = (",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "mqtt_client.on_connect",
        "kind": 5,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "mqtt_client.on_connect = on_connect\nmqtt_client.on_message = lambda client, userdata, msg: save_to_db(msg.topic, json.loads(msg.payload.decode('utf-8')))\ndef laj_koji_pase_ne_ujeda():\n    global last_pressed_ds1\n    global last_pressed_ds2\n    global security_timestamp\n    global house_keep\n    while True:\n        if house_keep:\n            if last_pressed_ds1 > 0 and time.time() - last_pressed_ds1 > 5 and last_released_ds1 <= last_pressed_ds1:",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "mqtt_client.on_message",
        "kind": 5,
        "importPath": "server.server",
        "description": "server.server",
        "peekOfCode": "mqtt_client.on_message = lambda client, userdata, msg: save_to_db(msg.topic, json.loads(msg.payload.decode('utf-8')))\ndef laj_koji_pase_ne_ujeda():\n    global last_pressed_ds1\n    global last_pressed_ds2\n    global security_timestamp\n    global house_keep\n    while True:\n        if house_keep:\n            if last_pressed_ds1 > 0 and time.time() - last_pressed_ds1 > 5 and last_released_ds1 <= last_pressed_ds1:\n                alarm_set_on()",
        "detail": "server.server",
        "documentation": {}
    },
    {
        "label": "load_settings",
        "kind": 2,
        "importPath": "server.settings",
        "description": "server.settings",
        "peekOfCode": "def load_settings():\n    file_path = \"settings.json\"\n    with open(file_path, 'r') as f:\n        return json.load(f)\nlock = threading.Lock()",
        "detail": "server.settings",
        "documentation": {}
    },
    {
        "label": "HOSTNAME",
        "kind": 5,
        "importPath": "server.settings",
        "description": "server.settings",
        "peekOfCode": "HOSTNAME = \"192.168.1.100\"\nPORT = 1883\nlock = threading.Lock()\ndef load_settings():\n    file_path = \"settings.json\"\n    with open(file_path, 'r') as f:\n        return json.load(f)\nlock = threading.Lock()",
        "detail": "server.settings",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": "server.settings",
        "description": "server.settings",
        "peekOfCode": "PORT = 1883\nlock = threading.Lock()\ndef load_settings():\n    file_path = \"settings.json\"\n    with open(file_path, 'r') as f:\n        return json.load(f)\nlock = threading.Lock()",
        "detail": "server.settings",
        "documentation": {}
    },
    {
        "label": "lock",
        "kind": 5,
        "importPath": "server.settings",
        "description": "server.settings",
        "peekOfCode": "lock = threading.Lock()\ndef load_settings():\n    file_path = \"settings.json\"\n    with open(file_path, 'r') as f:\n        return json.load(f)\nlock = threading.Lock()",
        "detail": "server.settings",
        "documentation": {}
    },
    {
        "label": "lock",
        "kind": 5,
        "importPath": "server.settings",
        "description": "server.settings",
        "peekOfCode": "lock = threading.Lock()",
        "detail": "server.settings",
        "documentation": {}
    }
]